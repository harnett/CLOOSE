function varargout = GUI_SfN(varargin)
% GUI_SFN MATLAB code for GUI_SfN.fig
%      GUI_SFN, by itself, creates a new GUI_SFN or raises the existing
%      singleton*.
%
%      H = GUI_SFN returns the handle to a new GUI_SFN or the handle to
%      the existing singleton*.
%
%      GUI_SFN('CALLBACK',hObject,evarduinarduientData,handles,...) calls the local
%      function named CALLBACK in GUI_SFN.M with the given input arguments.
%
%      GUI_SFN('Property','Value',...) creates a new GUI_SFN or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before GUI_SfN_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to Run_GUI_OpenipusngFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help GUI_SfN

% Last Modified by GUIDE v2.5 02-Oct-2024 18:37:49

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @GUI_SfN_OpeningFcn, ...
                   'gui_OutputFcn',  @GUI_SfN_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT

% --- Executes just before GUI_SfN is made visible.
function GUI_SfN_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to fnroiigure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to GUI_SfN (see VARARGIN)

% handles.peaks=peaks(35);
% handles.membrane=membrane;
% [x,y] = meshgrid(-8:.5:8);
% r = sqrt(x.^2+y.^2) + eps;
% sinc = sin(r)./r;
% handles.sinc = sinc;
% % Set the current data value.
% handles.current_data = handles.peaks;
% surf(handles.current_data)

% Choose default command line output for GUI_SfN
handles.output = hObject;
handles.ROIdrawNum = 0;
% Update handles structure
guidata(hObject, handles);

% UIWAIT makes GUI_SfN wait for user response (see UIRESUME)
% uiwait(handles.figure1);

function checkbox2_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% --- Executes on button press in checkbox4.
function checkbox4_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% --- Executes on button press in checkbox3.
function checkbox3_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% --- Outputs from this function are returned to the command line.
function varargout = GUI_SfN_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;

% --- Executes on button press in pushbutton2.
function pushbutton2_Callback(hObject, eventdata, handles)

% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Here we call some default settings for setting up Psychtoolbox

global tts vx vy 



mc = get(handles.checkbox12,'Value');
if mc == 1
    fft_tt64s = nan(128, 199, 3);
    
    vx1 = vy; %[vx vx*3-1; vx vx*3-1];
    vy1 = vx; %[vy vy*2-1; vy*2 vy*3-1];
    for i = 1:size(vx1,1)
        fft_tts(:,:,i) = fft2(tts(vx1(i,1):vx1(i,2), vy1(i,1):vy1(i,2)));
    end
%     fft_tts = uint16(fft_tts); 
end

clear arduino
arduino = serialport('COM3', 9600);
flush(arduino);
fprintf('Connection established with Arduino\n')

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
end
directory = get(handles.edit11, 'String');
if saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
end

listing = dir([directory '\Baseline\']);
table = struct2table(listing); 
sortedT = sortrows(table, 'date');
sortedS = table2struct(sortedT);

% load([directory '\Baseline\' sortedS(end-2).name]);
% bline_loaded = [directory '\Baseline\' sortedS(end-2).name];

if sortedS(end).isdir == 0
    load([directory '\Baseline\' sortedS(end).name]);
    bline_loaded = [directory '\Baseline\' sortedS(end).name];
elseif sortedS(end).isdir == 1
    if sortedS(end - 1).isdir == 1
        load([directory '\Baseline\' sortedS(end-2).name]);
        bline_loaded = [directory '\Baseline\' sortedS(end-2).name];
    elseif sortedS(end - 1).isdir == 0
        load([directory '\Baseline\' sortedS(end-1).name]);
        bline_loaded = [directory '\Baseline\' sortedS(end-1).name];
    end
end
if isfield(baseline, 'fullrec')
    baseline = rmfield(baseline, 'fullrec');
end
baseline.mean = double(baseline.mean);
baseline.F0 = double(baseline.F0);
subpop1 = baseline.subpop1;
subpop2 = baseline.subpop2;

pixelsX = str2double(get(handles.edit21,'string'));
LinesY  = str2double(get(handles.edit20,'string'));
FramesZ = str2double(get(handles.edit22,'string'));
ITI = str2double(get(handles.edit28,'string'));
fold = str2double(get(handles.edit30,'string'));
if fold ~= 0
    fold_fct = LinesY./fold;
end


plane_num = str2double(get(handles.edit18,'string'));
plane_tot = str2double(get(handles.edit19,'string'));
if ~isempty(get(handles.edit9,'string'))
    totTrials = str2double(get(handles.edit9,'string'));
end
tot_fr = (((FramesZ*plane_tot)+ITI)*totTrials);

frames_sampled = plane_num:plane_tot:tot_fr;

set(handles.edit23, 'String', baseline.selected_tresh);

% cla(handles.axes4,'reset');
hp = handles.axes4;
hp.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
hp.Toolbar = [];
colormap(hp, gray);

% Screen('Preference','SkipSyncTests', 1); 
PsychDefaultSetup(2);
% Seed the random number generator. Here we use the an older way to be
% compatible with older systems. Newer syntax would be rng('shuffle'). Look
% at the help function of rand "help rand" for more information
rand('seed', sum(100 * clock));

% Screen Number
screenNumber = 2;%min(Screen('Screens'));

% Define black, white and grey
white = WhiteIndex(screenNumber);
grey = white / 2;
black = BlackIndex(screenNumber);

% Open the screen
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);
                                          
% Flip to clear
Screen('Flip', window);

% Query the frame duration
ifi = Screen('GetFlipInterval', window);

% Maximum priority level
topPriorityLevel = MaxPriority(window);

% Get the centre coordinate of the window
[xCenter, yCenter] = RectCenter(windowRect);

%--------------------
% Gabor information
%--------------------

% Dimensions
% gaborDimPix = 500;
gaborDimPixX = windowRect(3);
gaborDimPixY = windowRect(4);

% Sigma of Gaussian
sigma = gaborDimPixX/8;

% Obvious Parameters
orientation = 90;
contrast = 1;
aspectRatio = 1;

% Spatial Frequency (Cycles Per Pixel)
% One Cycle = Grey-Black-Grey-White-Grey i.e. One Black and One White Lobe
if ~isempty(get(handles.edit7,'string'))
    numCycles = str2double(get(handles.edit7,'string'));
else
    warning('Spatial Frequency automatically set to 5')
    numCycles = 5;
end
freq = numCycles / gaborDimPixX;


% Build a procedural gabor texture
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixY,...
    [], [0.5 0.5 0.5 1], 1, 10);

% Positions of the Gabors
dim = 8;
[x, y] = meshgrid(-dim:dim, -dim:dim);

% Calculate the distance in "Gabor numbers" of each gabor from the center
% of the array
dist = sqrt(x.^2 + y.^2);

% Cut out an inner annulus
innerDist = 3.5;
x(dist <= innerDist) = nan;
y(dist <= innerDist) = nan;

% Cut out an outer annulus
outerDist = 10;
x(dist >= outerDist) = nan;
y(dist >= outerDist) = nan;

% Select only the finite values
x = x(isfinite(x));
y = y(isfinite(y));

% Center the annulus coordinates in the centre of the screen
xPos = x .* gaborDimPixX + xCenter;
yPos = y .* gaborDimPixY + yCenter;

% Count how many Gabors there are
nGabors = numel(xPos);

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixY];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

% Drift speed for the 2D global motion
degPerSec = 360 * 2;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

% Perform initial flip to gray background and sync us to the retrace:
vbl = Screen('Flip', window);

% Numer of frames to wait before re-drawing
waitframes = 1;

% angle to show
angle = 1:360;
% Animation loop
% while ~KbCheck
if ~isempty(get(handles.edit13,'string'))
    targetAngle = str2double(get(handles.edit13,'string'));
else
    error('Select a target angle')
end
angle_bins  = mod((targetAngle - 90), 360) : 15 : targetAngle;
act_bins  = nan(1, 7);
act_bins(2:7)  = linspace(baseline.selected_range, baseline.selected_tresh, 6); 
act_bins(1) = act_bins(2) - (act_bins(3) - act_bins(2));
act_bins = act_bins - baseline.selected_range;
% xx = mod((targetAngle - 90), 360);

rotation = nan(1,FramesZ);
rotation(1) = 0;
licks = nan(1,FramesZ);
licks(1) = 0;

cla(handles.axes1,'reset');
h = line(nan, nan,'Parent',handles.axes1,'Color', 'k', 'LineWidth', 1);
% h.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
% h.Toolbar = [];
axis(handles.axes1,[-89,0,-5,90]);
set(h,'XData', -89:0);


cla(handles.axes3,'reset');
h3 = line(nan(1,2), nan,'Parent',handles.axes3); %,'Color', 'k', 'LineWidth', 1);
% h3.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
% h3.Toolbar = [];
axis(handles.axes3,[-89,0,0,2]);
set(h3(1:end),'XData', -89:0);



roiMask = baseline.roiMask;
F0_moving = baseline.roiData(:,end-((FramesZ)*4)+1:end);
nroi = baseline.nroi;
loops = 0;
ard = 0;
success = 0;
aversive = 0;



StimData.subpop1 = subpop1;
StimData.subpop2 = subpop2;
if ~isempty (subpop2)
    StimData.multiple_subpops = true;
    npops = 1;
    rng = baseline.selected_range;
    thresh = baseline.selected_tresh;
    N_above = baseline.selected_tresh - baseline.selected_range;
else
    StimData.multiple_subpops = false;
    npops = 0;
    rng = 0;
    thresh = baseline.selected_tresh;
    N_above = baseline.selected_tresh;
end
StimData.('TStampGlobal') = nan(1, tot_fr);
StimData.('Angle')  = nan(1, tot_fr/plane_tot);
StimData.('targetAngle') = targetAngle;
StimData.('z_score')  = nan(1, tot_fr/plane_tot);
StimData.('Licks')  = ones(1, tot_fr/plane_tot);
StimData.('Reward_frames')  = zeros(1, tot_fr/plane_tot);
StimData.('Opto')  = zeros(1, tot_fr);
StimData.('Aversive_frames')  = zeros(1, tot_fr/plane_tot);
StimData.('bline_loaded')  = bline_loaded;

StimData.('ImTranslateXY')  = nan(2, tot_fr/plane_tot);

StimData.NewTrial = nan(1, 250);
StimData.F0 = nan(nroi, tot_fr/plane_tot);
StimData.Noise_exp = 0;
StimData.Noise_df = 0;
StimData.mapping = linspace(rng, thresh, 90);
rotation = nan(1,tot_fr/plane_tot);
rotation(1) = 0;
shown = nan(1,tot_fr/plane_tot);
shown(1) = 0;
licks = nan(1,tot_fr/plane_tot);
licks(1:plane_tot) = 0;
idx = nan(1, tot_fr/plane_tot);
x = nan(1, tot_fr/plane_tot);
x(1:5) = 0;
tt = 0;
xpt = 0;
ypt = 0;
roi_one_frame = nan(nroi,tot_fr/plane_tot);
n = 0;
pl = 0;
new_trial_fr = 0;
rot_oneTrial = zeros(1, FramesZ);
avv = 0;
scc = 0;
ITI_f = 90;

sent_data = 'a';
write(arduino,sent_data, 'char');

ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
    'OutputBufferSize', 12, 'Terminator', 'CR/LF');
fopen(ServerSend);
fwrite(ServerSend, uint32([tot_fr plane_num plane_tot]), 'uint32');
fclose(ServerSend);

tcpipServer = tcpip('10.93.6.2',30000,'NetworkRole','client', 'Terminator', 'CR/LF');
tcpipServer.InputBufferSize = (pixelsX*LinesY*200);
fopen(tcpipServer);
Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');

while pl < tot_fr
    
    pl = pl +1;
    if pl == 1
        timerVal = tic;
    end
    
    StimData.TStampGlobal(1, pl) = toc(timerVal);
    
    rawData = uint16(fread(tcpipServer,(pixelsX*LinesY),'uint16'));
    rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
    rawData_tmp = permute(rawData_tmp, [2 1]);
    rawData_tmp = imcomplement(rawData_tmp);
    
    try
        if handles.radiobutton24.Value == 1
            sent_data = 'c';
            StimData.Opto(pl) = 1;
            write(arduino,sent_data, 'char');
        end
    catch
        clear arduino
        arduino = serialport('COM3', 9600);
        ard = 0;
        disp('Connection with Arduino re-established')
        if handles.radiobutton24.Value == 1
            sent_data = 'c';
            StimData.Opto(pl) = 1;
            write(arduino,sent_data, 'char');
        end
    end
    
    if sum(ismember(pl, frames_sampled)) == 0
        continue
    end
    if fold ~= 0
        r_tmp = uint16(zeros(fold, pixelsX, fold_fct));
        for ifc = 1:fold_fct %#ok<BDSCI>
            fuck_index = (fold*(ifc-1))+ 1 : fold*ifc;
            r_tmp(:, :, ifc) = rawData_tmp(fuck_index, :, 1);
        end
        rawData_tmp = uint16(mean(r_tmp, 3));
    end
    n = n+1;
    new_trial_fr = new_trial_fr + 1;
    
    if new_trial_fr == 1
        loops = loops + 1;
        Prop_success = round((success/loops)*100);
        newS = sprintf('%d', int32(Prop_success));
        set(handles.edit25, 'String', newS );
        StimData.NewTrial(loops) = n;

        Prop_aversive = round((aversive/loops)*100);
        newA = sprintf('%d', int32(Prop_aversive));
        set(handles.edit26, 'String', newA );
        
        newString = sprintf('%d', int32(loops));
        set(handles.edit10, 'String', newString );
    end
    
    if mc == 1
        output = nan(3, 4);
        for i = 1:size(fft_tts, 3)
            output(i,:) = dftregistration(fft_tts(:,:,i), fft2(double(rawData_tmp(vx1(i,1):vx1(i,2), vy1(i,1):vy1(i,2)))));
        end
        xsh = round(nanmedian(output(:,4)));
        ysh = round(nanmedian(output(:,3)));
        rawData_tmp = imtranslate(rawData_tmp, [xsh ysh]);
        StimData.ImTranslateXY(:, n)  = [xsh; ysh];

    end
    
    if n == 1
        % hp = image(im2uint8(rawData_tmp)); 
        hp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hp, 'border', 'tight');
    end
    
    for i = 1:nroi
        roi_one_frame(i,n) = double(mean(rawData_tmp(roiMask{i, 1})));
    end
    F0_moving(:,2:end) = F0_moving(:,1:end-1);
    F0_moving(:,1) = roi_one_frame(:,n);
    StimData.F0(:,n) = prctile(F0_moving, 10, 2);
    
    if npops == 0
        x(n) = mean((roi_one_frame(:,n) - (StimData.F0))./(StimData.F0));
        if x(n) < 0
            x(n) = 0;
        end
    elseif npops == 1
        dfpop1 = mean((roi_one_frame(subpop1,n) - (StimData.F0(subpop1,n)))./(StimData.F0(subpop1,n)));
        dfpop2 = mean((roi_one_frame(subpop2,n) - (StimData.F0(subpop2,n)))./(StimData.F0(subpop2,n)));
        x(n) = (dfpop1 - dfpop2);
    end
    
    if n >= 3
        z = mean(x(n-2:n)) - rng;
    else
        z = x(n) - rng;
    end
    
    try
        idx(n) = max(find(z >= act_bins)); %#ok<MXFND>
    catch
        idx(n) = 1;
    end
    
    xx = angle_bins(idx(n));
    
    if new_trial_fr <= 15
        rotation(n) = round((z/N_above)*90);
        shown(n) = -5;
        rot_oneTrial(new_trial_fr) = 0;
        StimData.Angle(n)  = -5;
        if new_trial_fr == 1
            Screen('FillRect', window, [0.5 0.5 0.5]);
            Screen('Flip', window, 0, 1);
        end
    elseif new_trial_fr > 15 && new_trial_fr <= FramesZ
        if sum(rot_oneTrial >= 90) == 0 && sum(rot_oneTrial < 0) == 0
            ypt = ypt + 1;
            rotation(n) = round((z/N_above)*90);
            shown(n) = rotation(n);
            rot_oneTrial(new_trial_fr) = rotation(n);
            StimData.Angle(n)  = xx;
            if idx(n) ~= idx(n -1) || ypt == 1
                Screen('DrawTexture', window, gabortex, [], [], xx,...
                    [], [], [], [], kPsychDontDoRotation, propertiesMat');
                Screen('Flip', window, 0, 1);
            end
%             if new_trial_fr == FramesZ
%                 white_noise(2);
%                 %                         StimData.Noise_Amp = noise_amp;
%                 StimData.Aversive_frames(n) = 1;
%             end
        elseif sum(rot_oneTrial >= 90) > 0
            tt = tt+1;
            if tt < 60
                rotation(n) = round((z/N_above)*90);
                shown(n) = targetAngle;
                rot_oneTrial(new_trial_fr) = 90;
                StimData.Angle(n)  = targetAngle;
                if idx(n) ~= idx(n -1)
                    Screen('DrawTexture', window, gabortex, [], [], targetAngle,...
                        [], [], [], [], kPsychDontDoRotation, propertiesMat');
                    Screen('Flip', window, 0, 1);
                end
                if tt == 1
                    flush(arduino)
                elseif tt == 3
                    try
                        if handles.radiobutton24.Value == 1
                            if handles.radiobutton9.Value == 1
                                sent_data = 'c';
                                StimData.Reward_frames(n) = 0;
                                StimData.Opto(n) = 1;
                            elseif handles.radiobutton8.Value == 1
                                sent_data = 'd';
                                StimData.Reward_frames(n) = 1;
                                StimData.Opto(n) = 1;
                            elseif  handles.radiobutton23.Value == 1
                                sent_data = 'b';
                                StimData.Reward_frames(n) = 1;
                                StimData.Opto(n) = 0;
                            end
                            write(arduino,sent_data, 'char');
                        end
                    catch
                        clear arduino
                        arduino = serialport('COM3', 9600);
                        ard = 0;
                        disp('Connection with Arduino re-established')
                        if handles.radiobutton24.Value == 1
                            if handles.radiobutton9.Value == 1
                                sent_data = 'c';
                                StimData.Reward_frames(n) = 0;
                                StimData.Opto(n) = 1;
                            elseif handles.radiobutton8.Value == 1
                                sent_data = 'd';
                                StimData.Reward_frames(n) = 1;
                                StimData.Opto(n) = 1;
                            elseif  handles.radiobutton23.Value == 1
                                sent_data = 'b';
                                StimData.Reward_frames(n) = 1;
                                StimData.Opto(n) = 0;
                            end
                            write(arduino,sent_data, 'char');
                        end
                    end
%                     StimData.Reward_frames(n) = 1;
                    success = success + 1;
                    scc = 1;
                    ITI_f = 15;
                end
%             elseif tt > 30 && tt < 60
%                 xpt = xpt + 1;
%                 rotation(n) = round((z/N_above)*90);
%                 shown(n) = -1;
%                 rot_oneTrial(new_trial_fr) = 0;
%                 StimData.Angle(n)  = -1;
%                 if xpt == 1
%                     Screen('FillRect', window, [0.5 0.5 0.5]);
%                     Screen('Flip', window, 0, 1);
%                 end
            elseif tt == 60
                tt = 0;
                ypt = 0;
                new_trial_fr  = FramesZ;
                rotation(n) = round((z/N_above)*90);
                shown(n) = -1;
                StimData.Angle(n)  = -1;
            end
        elseif sum(rot_oneTrial < 0) > 0
            tt = tt+1;
            if tt < 60
                rotation(n) = round((z/N_above)*90);
                shown(n) = 0;
                rot_oneTrial(new_trial_fr) = 0;
                StimData.Angle(n)  = 0;
                if idx(n) ~= idx(n -1)
                    Screen('DrawTexture', window, gabortex, [], [], 0,...
                        [], [], [], [], kPsychDontDoRotation, propertiesMat');
                    Screen('Flip', window, 0, 1);
                end
                if tt == 1
                    white_noise(2);
                    StimData.Noise_df = 1;
                    %                         StimData.Noise_Amp = noise_amp;
                    StimData.Aversive_frames(n) = 1;
                    aversive = aversive + 1;
                    avv = 1;
                    ITI_f = 15;
                end
%             elseif tt >= 30 && tt < 60
%                 xpt = xpt + 1;
%                 rotation(n) = round((z/N_above)*90);
%                 shown(n) = -1;
%                 rot_oneTrial(new_trial_fr) = 0;
%                 StimData.Angle(n)  = -1;
%                 if xpt == 1
%                     Screen('FillRect', window, [0.5 0.5 0.5]);
%                     Screen('Flip', window, 0, 1);
%                 end
            elseif tt == 60
                tt = 0;
                ypt = 0;
%                 xpt = 0;
                new_trial_fr  = FramesZ;
                rotation(n) = round((z/N_above)*90);
                shown(n) = -1;
                StimData.Angle(n)  = -1;
            end
        end
%         if avv == 1
%             ITI_f = 8;
%         elseif scc == 1
%             ITI_f = 8;
%         elseif avv == 0 && scc == 0
%             ITI_f = 45;
%         end
        
    elseif new_trial_fr > FramesZ && new_trial_fr < FramesZ + (ITI_f)
        if new_trial_fr == FramesZ + 1 && ITI_f == 90
            Screen('FillRect', window, [0 0 0]);
            Screen('Flip', window, 0, 1);
        elseif new_trial_fr == FramesZ + 1 && ITI_f == 15
            Screen('FillRect', window, [0.5 0.5 0.5]);
            Screen('Flip', window, 0, 1);
        end
        rotation(n) = round((z/N_above)*90);
        shown(n) = -1;
        StimData.Angle(n)  = -1;
        if new_trial_fr == FramesZ + 30 && ITI_f == 90
            white_noise(2);
%             StimData.Noise_df = 1;
            StimData.Aversive_frames(n) = 1;
        end
    elseif new_trial_fr == FramesZ + (ITI_f)
        tt = 0;
        ypt = 0;
        xpt = 0;
        new_trial_fr = 0;
        rot_oneTrial = zeros(1, FramesZ);
        rotation(n) = round((z/N_above)*90);
        shown(n) = -1;
        StimData.Angle(n)  = -1;
        avv = 0; scc = 0; ITI_f = 90;
    end
    
    set(hp, 'CData',im2uint16(rawData_tmp));
    
    try
        StimData.Licks(n)  = read(arduino, 1, 'uint8');
        flush(arduino, 'input');
        ard = 0;
    catch
        if n > 1
            StimData.Licks(n)  = StimData.Licks(n-1) - 1;
        end
        ard = ard +1;
        if ard == 1
            warning ('No Info From Arduino')
            clear arduino
            arduino = serialport('COM3', 9600);
            flush(arduino);
            disp('Connection with Arduino re-established')
        end
    end
    
    if n > 1 && (StimData.Licks(n) - StimData.Licks(n-1)) ~= 0
        licks(n) = 1;
    elseif n > 1 && (StimData.Licks(n) - StimData.Licks(n-1)) == 0
        licks(n) = 0;
    end
        
    if n < 90
        pltRot = fliplr(shown(1:n));
        pltRot(end+1 : 90) = nan;
        pltRot = fliplr(pltRot);
        
        pltLick = fliplr(licks(1:n));
        pltLick(end+1 : 90) = nan;
        pltLick = fliplr(pltLick);
        
        pltRew = fliplr(StimData.Reward_frames(1:n));
        pltRew(end+1 : 90) = nan;
        pltRew = fliplr(pltRew);
    else
        pltRot  = shown(n-89 : n);
        pltLick = licks(n-89 : n);
        pltRew = StimData.Reward_frames(n-89 : n);
    end
    set(h,'YData',pltRot);
    set(h3(1), 'YData', pltLick);
    set(h3(2), 'YData', pltRew);
    
    if rem(n, 10)
        try
            drawnow limitrate nocallbacks
        catch
            warning('Could not plot')
        end
    end
end
    
% if StimData.Reward == 0 && StimData.Noise_df == 0
%     StimData.Noise_exp = 1;
% end
StimData.Rotation = rotation;
StimData.RoiPerFrame  = roi_one_frame;
StimData.z_score  = x;
StimData.numCycles = numCycles;
StimData.threshold_used = {rng; thresh};
StimData.b_line_all = baseline.F0;
StimData.plane_num = plane_num;
StimData.plane_tot = plane_tot;
% StimData.ang_show = shown;
% StimData.F0 = F0;
StimData.RefImage = tts;

if saveTrials == 1
    Folder = '\BCI_Trials';
    filename = ['\' num2str(1)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename], 'StimData', '-v6')
end
fprintf('That is it. Saving data')

% Clean up
fclose(tcpipServer);
delete(tcpipServer);
delete(ServerSend);
ServerSend = [];
clear all
sca;

% --- Executes on button press in pushbutton3.
function pushbutton3_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Here we call some default settings for setting up Psychtoolbox

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
end
directory = get(handles.edit11, 'String');
if saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
end

Files = dir(fullfile([directory '\BCI_Trials'], '*.mat'));
rnd = randi([1 size(Files,1)]);
file2load = load([directory '\BCI_Trials\' Files(rnd).name]);

PsychDefaultSetup(2);

% Seed the random number generator. Here we use the an older way to be
% compatible with older systems. Newer syntax would be rng('shuffle'). Look
% at the help function of rand "help rand" for more information
rand('seed', sum(100 * clock));

% Screen Number
screenNumber = 2;%min(Screen('Screens'));

% Define black, white and grey
white = WhiteIndex(screenNumber);
grey = white / 2;
black = BlackIndex(screenNumber);

% Open the screen
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);

% Flip to clear
Screen('Flip', window);

% Query the frame duration
ifi = Screen('GetFlipInterval', window);

% Maximum priority level
topPriorityLevel = MaxPriority(window);

% Get the centre coordinate of the window
[xCenter, yCenter] = RectCenter(windowRect);

%--------------------
% Gabor information
%--------------------

% Dimensions
% gaborDimPix = 500;
gaborDimPixX = windowRect(3);
gaborDimPixY = windowRect(4);

% Sigma of Gaussian
sigma = gaborDimPixX;

% Obvious Parameters
orientation = 90;
contrast = 1;
aspectRatio = 5;

% Spatial Frequency (Cycles Per Pixel)
% One Cycle = Grey-Black-Grey-White-Grey i.e. One Black and One White Lobe
if ~isempty(get(handles.edit7,'string'))
    numCycles = str2double(get(handles.edit7,'string'));
else
    warning('Spatial Frequency automatically set to 5')
    numCycles = 5;
end
freq = numCycles / gaborDimPixX;


% Build a procedural gabor texture
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixY,...
    [], [1 1 1 0.5], 1, 100);

% Positions of the Gabors
dim = 8;
[x, y] = meshgrid(-dim:dim, -dim:dim);

% Calculate the distance in "Gabor numbers" of each gabor from the center
% of the array
dist = sqrt(x.^2 + y.^2);

% Cut out an inner annulus
innerDist = 3.5;
x(dist <= innerDist) = nan;
y(dist <= innerDist) = nan;

% Cut out an outer annulus
outerDist = 10;
x(dist >= outerDist) = nan;
y(dist >= outerDist) = nan;

% Select only the finite values
x = x(isfinite(x));
y = y(isfinite(y));

% Center the annulus coordinates in the centre of the screen
xPos = x .* gaborDimPixX + xCenter;
yPos = y .* gaborDimPixY + yCenter;

% Count how many Gabors there are
nGabors = numel(xPos);

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixY];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

% Drift speed for the 2D global motion
degPerSec = 360 * 2;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

% Perform initial flip to gray background and sync us to the retrace:
vbl = Screen('Flip', window);

% Numer of frames to wait before re-drawing
waitframes = 1;

% angle to show
angle = 1:360;
n = 0;
% Animation loop
% while ~KbCheck
targetAngle = file2load.StimData.targetAngle; 

xx = mod((targetAngle - 90), 360);
rotation = 0;
cla(handles.axes1,'reset');
h = animatedline(handles.axes1);
axis(handles.axes1,[0,1500,0,90]);

trig = get(handles.checkbox10,'Value');
if trig == 1 
    ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
        'OutputBufferSize', 2, 'Terminator', 'CR/LF');
    fopen(ServerSend);
    fwrite(ServerSend, uint16(0), 'uint16');
    fclose(ServerSend);
    delete(ServerSend);
    ServerSend = [];
end


StimData.('TStampGlobal') = nan(1, length(file2load.StimData.Angle));
StimData.('Angle')  = nan(1, length(file2load.StimData.Angle));
StimData.('Rotation')  = nan(1, length(file2load.StimData.Angle) );
StimData.('targetAngle') = targetAngle;

timerVal = tic;

for i = 1: length(file2load.StimData.Angle)    
    % Set the right blend function for drawing the gabors
    Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');
    
    % Batch draw all of the Gabors to screen
    xx = file2load.StimData.Angle(i);
    rotation = mod((targetAngle - xx), 360);
    Screen('DrawTexture', window, gabortex, [], [], xx,...
        [], [], [], [], kPsychDontDoRotation, propertiesMat');
    
    addpoints(h, i, rotation)
    drawnow limitrate nocallbacks
    
    StimData.TStampGlobal(i) = toc(timerVal); 
    StimData.Angle(i)  = xx;
    StimData.Rotation(i)  = rotation;
    Screen('Flip', window);
end
if xx >= targetAngle
    StimData.Reward = 1;
elseif xx < targetAngle
    StimData.Reward = 0;
end
StimData.numCycles = numCycles;

hold off
if saveTrials == 1
    currentCounterValue = str2double(get(handles.edit10, 'String'));
    newString = sprintf('%d', int32(currentCounterValue +1));
    set(handles.edit10, 'String', newString );
    
    trialNumber = currentCounterValue;
    Folder = '\Playback';
    filename = ['\' num2str(trialNumber)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename], 'StimData')
end
% Clean up
sca;


function pushbutton5_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
end
directory = get(handles.edit11, 'String');
if saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
end
% Here we call some default settings for setting up Psychtoolbox
PsychDefaultSetup(2);

% Seed the random number generator. Here we use the an older way to be
% compatible with older systems. Newer syntax would be rng('shuffle'). Look
% at the help function of rand "help rand" for more information
rand('seed', sum(100 * clock));

% Screen Number
screenNumber = 2;%min(Screen('Screens'));

% Define black, white and grey
white = WhiteIndex(screenNumber);
grey = white / 2;
black = BlackIndex(screenNumber);

% Open the screen
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);

% Flip to clear
Screen('Flip', window);

% Query the frame duration
ifi = Screen('GetFlipInterval', window);

% Maximum priority level
topPriorityLevel = MaxPriority(window);

% Get the centre coordinate of the window
[xCenter, yCenter] = RectCenter(windowRect);

%--------------------
% Gabor information
%--------------------

% Dimensions
% gaborDimPix = 500;
gaborDimPixX = windowRect(3);
gaborDimPixY = windowRect(4);

% Sigma of Gaussian
sigma = gaborDimPixX ;

% Obvious Parameters
orientation = 90;
contrast = 1;
aspectRatio = 5;

% Spatial Frequency (Cycles Per Pixel)
% One Cycle = Grey-Black-Grey-White-Grey i.e. One Black and One White Lobe
if ~isempty(get(handles.edit5,'string'))
    numCycles = str2double(get(handles.edit5,'string'));
else
    warning('Spatial Frequency automatically set to 5')
    numCycles = 5;
end
freq = numCycles / gaborDimPixX;

% Build a procedural gabor texture
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixY,...
    [], [1 1 1 0.5], 1, 100);

% Positions of the Gabors
dim = 8;
[x, y] = meshgrid(-dim:dim, -dim:dim);

% Calculate the distance in "Gabor numbers" of each gabor from the center
% of the array
dist = sqrt(x.^2 + y.^2);

% Cut out an inner annulus
innerDist = 3.5;
x(dist <= innerDist) = nan;
y(dist <= innerDist) = nan;

% Cut out an outer annulus
outerDist = 10;
x(dist >= outerDist) = nan;
y(dist >= outerDist) = nan;

% Select only the finite values
x = x(isfinite(x));
y = y(isfinite(y));

% Center the annulus coordinates in the centre of the screen
xPos = x .* gaborDimPixX + xCenter;
yPos = y .* gaborDimPixY + yCenter;

% Count how many Gabors there are
nGabors = numel(xPos);

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixY];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

% Drift speed for the 2D global motion
if ~isempty(get(handles.edit6,'string'))
    tFreq = str2double(get(handles.edit6,'string'));
else
    warning('Temporal Frequency automatically set to 2')
    tFreq = 2;
end
degPerSec = 360 * tFreq;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = 0; % rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = 0.5;% rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

vbl = Screen('Flip', window);

waitframes = 1;

AngleNumb = str2double(get(handles.uibuttongroup1.SelectedObject,'String'));
if AngleNumb == 8
    angles = 0:45:315;
elseif AngleNumb == 12
    angles = 0:30:330;
end



if ~isempty(get(handles.edit2,'string'))
    tgrey = str2double(get(handles.edit2,'string'));
else
    tgrey = 0;
end
if ~isempty(get(handles.edit3,'string'))
    tblack = str2double(get(handles.edit3,'string'));
else
    tblack = 0;
end
if ~isempty(get(handles.edit4,'string'))
    tdrift = str2double(get(handles.edit4,'string'));
else
    tdrift = 0;
end


presTimeDrift = repmat(tdrift, 1, numel(angles));
% Animation loop
% while ~KbCheck
greyShow = get(handles.checkbox3,'Value');
blackShow = get(handles.checkbox4,'Value');
randomShow = get(handles.checkbox2,'Value');



if randomShow == 1
    angles = angles(randperm(length(angles)));
end

if greyShow == 1
    GreyStim = repmat(5, 1, numel(angles)+1);
    presTimeGrey = repmat(tgrey, 1, numel(angles)+1);
    
    vStim = nan(1,length(angles) + length(GreyStim));
    vStim(1:2:end) = GreyStim;
    vStim(2:2:end) = angles;

    vStimTimes = nan(1,length(presTimeDrift) + length(presTimeGrey));
    vStimTimes(1:2:end) = presTimeGrey;
    vStimTimes(2:2:end) = presTimeDrift;
else
    vStim = angles;
    vStimTimes = presTimeDrift;
end

BlTime = tblack;
if blackShow == 1
    vStim = [3 vStim 3];
    vStimTimes = [BlTime vStimTimes BlTime];
end

trig = get(handles.checkbox9,'Value');
if trig == 1 
    ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
        'OutputBufferSize', 12, 'Terminator', 'CR/LF');
    fopen(ServerSend);
    fwrite(ServerSend, uint32([0 1 1]), 'uint32');
    fclose(ServerSend);
    delete(ServerSend);
    ServerSend = [];
end

tduration = sum(vStimTimes,2);
StimData(1).('TStamp') = nan(1, round(length(tduration/ifi)*1.5));
StimData(1).('Angle')  = nan(1, round(length(tduration/ifi)*1.5));
n = 0;
timerGlobal = tic;

repetions = 100;
rep = 0;
while rep < repetions
    rep = rep+1;
    for i = 1:numel(vStim)
        timerVal = tic;
        if vStim(i) ~= 3 && vStim(i) ~= 5
            while toc(timerVal) < vStimTimes(i)
                % Set the right blend function for drawing the gabors
                Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');
                % Draw texture
                Screen('DrawTexture', window, gabortex, [], [], vStim(i),...
                    [], [], [], [], kPsychDontDoRotation, propertiesMat');
                % Flip our drawing to the screen
                vbl = Screen('Flip', window, vbl + (waitframes - 0.5) * ifi);
                
                % Increment the phase of our Gabors
                phaseLine = phaseLine + degPerFrameGabors;
                propertiesMat(:, 1) = phaseLine';
                
                n = n+1;
                StimData.TStampGlobal(n) = toc(timerGlobal);
                StimData.TStampLocal(n) = toc(timerVal);
                StimData.Angle(n)  = vStim(i);
            end
        elseif vStim(i) == 5
            while toc(timerVal) < vStimTimes(i)
                % Color the screen a random color
                Screen('FillRect', window, [0.5 0.5 0.5]);
                
                % Flip to the screen
                vbl = Screen('Flip', window, vbl + (waitframes - 0.5) * ifi);
                
                n = n+1;
                StimData.TStampGlobal(n) = toc(timerGlobal);
                StimData.TStampLocal(n) = toc(timerVal);
                StimData.Angle(n)  = vStim(i);
            end
        elseif vStim(i) == 3
            while toc(timerVal) < vStimTimes(i)
                Screen('FillRect', window, [0 0 0]);
                
                vbl = Screen('Flip', window, vbl + (waitframes - 0.5) * ifi);
                
                n = n+1;
                StimData.TStampGlobal(n) = toc(timerGlobal);
                StimData.TStampLocal(n) = toc(timerVal);
                StimData.Angle(n)  = vStim(i);
            end
        end
    end
end
Fld = get(handles.uibuttongroup2.SelectedObject,'String');
if saveTrials == 1
    currentCounterValue = str2double(get(handles.edit10, 'String'));
    newString = sprintf('%d', int32(currentCounterValue +1));
    set(handles.edit10, 'String', newString );
    trialNumber = currentCounterValue;
    
    if strcmp(Fld,'Initial')
        Folder = '\Gratings_Start_Trials';
    elseif strcmp(Fld,'Final')
        Folder = '\Gratings_End_Trials';
    end
    filename = ['\' num2str(trialNumber)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename], 'StimData')
end
sca;

% --- Executes on selection change in popupmenu1.

function edit2_Callback(hObject, eventdata, handles)
% hObject    handle to edit2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit2 as text
%        str2double(get(hObject,'String')) returns contents of edit2 as a double

% --- Executes during object creation, after setting all properties.
function edit2_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit3_Callback(hObject, eventdata, handles)
% hObject    handle to edit3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit3 as text
%        str2double(get(hObject,'String')) returns contents of edit3 as a double


% --- Executes during object creation, after setting all properties.
function edit3_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit4_Callback(hObject, eventdata, handles)
% hObject    handle to edit4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit4 as text
%        str2double(get(hObject,'String')) returns contents of edit4 as a double


% --- Executes during object creation, after setting all properties.
function edit4_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit5_Callback(hObject, eventdata, handles)
% hObject    handle to edit5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit5 as text
%        str2double(get(hObject,'String')) returns contents of edit5 as a double


% --- Executes during object creation, after setting all properties.
function edit5_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit6_Callback(hObject, eventdata, handles)
% hObject    handle to edit6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit6 as text
%        str2double(get(hObject,'String')) returns contents of edit6 as a double


% --- Executes during object creation, after setting all properties.
function edit6_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit7_Callback(hObject, eventdata, handles)
% hObject    handle to edit7 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit7 as text
%        str2double(get(hObject,'String')) returns contents of edit7 as a double


% --- Executes during object creation, after setting all properties.
function edit7_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit7 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on mouse press over axes background.
function axes1_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to axes1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function edit9_Callback(hObject, eventdata, handles)
% hObject    handle to edit9 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit9 as text
%        str2double(get(hObject,'String')) returns contents of edit9 as a double


% --- Executes during object creation, after setting all properties.
function edit9_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit9 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in checkbox6.
function checkbox6_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox6


% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over checkbox6.
function checkbox6_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to checkbox6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function uibuttongroup1_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to uibuttongroup1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function edit10_Callback(hObject, eventdata, handles)
% hObject    handle to edit10 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit10 as text
%        str2double(get(hObject,'String')) returns contents of edit10 as a double


% --- Executes during object creation, after setting all properties.
function edit10_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit10 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit11_Callback(hObject, eventdata, handles)
% hObject    handle to edit11 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit11 as text
%        str2double(get(hObject,'String')) returns contents of edit11 as a double


% --- Executes during object creation, after setting all properties.
function edit11_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit11 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in radiobutton6.
function radiobutton6_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton6


% --------------------------------------------------------------------
function uibuttongroup2_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to uibuttongroup2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function edit13_Callback(hObject, eventdata, handles)
% hObject    handle to edit13 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit13 as text
%        str2double(get(hObject,'String')) returns contents of edit13 as a double


% --- Executes during object creation, after setting all properties.
function edit13_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit13 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in checkbox7.
function checkbox7_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox7 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox7


% --- Executes on button press in pushbutton2.
function BCI_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over pushbutton2.
function pushbutton2_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on button press in pushbutton6.
function pushbutton6_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton6 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global tts vx vy 

mc = get(handles.checkbox12,'Value');
h = handles.axes4;
% hold( h  , 'off')
AllignOnly = get(handles.checkbox13,'Value');

if ~isempty(get(handles.edit15,'string'))
    ind = str2double(get(handles.edit15,'string'));
else
    ind = 1;
    warning('You did not selet a starting frame. Defaults to 1')
end
if ~isempty(get(handles.edit17,'string'))
    num = str2double(get(handles.edit17,'string'));
else
    num = -1;
    warning('You did not selet how many frame you want to load. Defaults to all frames')
end
handles.num = num;

plane_num = str2double(get(handles.edit18,'string'));
plane_tot = str2double(get(handles.edit19,'string'));

answer = questdlg('How do you want to load your image', ...
    'Options', ...
    'Acquire new one','Load from directory','Acquire new one');

switch answer
    case 'Load from directory'
        if ~isempty(get(handles.edit14,'string'))
            fname = get(handles.edit14,'string');
        else
            error('Select a file on which you want to draw your ROIs')
        end
        rawData = sbxgrabframe(fname,ind,num);
        rawData = squeeze(double(rawData));
        rawData = rawData(:,:, plane_num:plane_tot:size(rawData,3));
    case 'Acquire new one'
        pixelsX = str2double(get(handles.edit21,'string'));
        LinesY  = str2double(get(handles.edit20,'string'));
        FramesZ = str2double(get(handles.edit17,'string'));
                fold = str2double(get(handles.edit30,'string'));
        if fold ~= 0
            fold_fct = LinesY./fold;
        end
        
        frames_sampled = plane_num:plane_tot:(FramesZ*plane_tot);
        
        ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
            'OutputBufferSize', 12, 'Terminator', 'CR/LF');
        fopen(ServerSend);
        fwrite(ServerSend, uint32([(FramesZ*plane_tot)  plane_num  plane_tot]), 'uint32');
        fclose(ServerSend);
        
        rawData_t = nan((pixelsX*LinesY),FramesZ);
        if fold ~= 0 
            rawData = uint16(zeros(fold, pixelsX, FramesZ));
        else
            rawData = uint16(zeros(LinesY, pixelsX, FramesZ));
        end
        tcpipServer = tcpip('10.93.6.2',30000,'NetworkRole','client',...
            'Terminator', 'CR/LF');
        tcpipServer.InputBufferSize = (pixelsX*LinesY*200);
        fopen(tcpipServer);
        
        pl = 0;
        n = 0;
        while pl < FramesZ*plane_tot
            
            pl = pl + 1;
            
            if sum(ismember(pl, frames_sampled)) == 0
                fread(tcpipServer,(pixelsX*LinesY),'uint16');
                continue
            else
                n = n+1;
                rawData_t(:,n) = fread(tcpipServer,(pixelsX*LinesY),'uint16');
            end
            
            rawData_tmp = uint16(reshape(rawData_t(:,n), pixelsX, LinesY));
            rawData_tmp = permute(rawData_tmp, [2 1]);
            rawData_tmp = imcomplement(rawData_tmp);
            
            if fold ~= 0 
                r_tmp = uint16(zeros(fold, pixelsX, fold_fct));
                for ifc = 1:fold_fct %#ok<BDSCI>
                    fuck_index = (fold*(ifc-1))+ 1 : fold*ifc;
                    r_tmp(:, :, ifc) = rawData_tmp(fuck_index, :, 1);
                end
                rawData_tmp = uint16(mean(r_tmp, 3));
            end
            rawData(:, :, n) = rawData_tmp;

            if n == 1
                h = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
            end
            set(h, 'CData', im2uint16(rawData_tmp));
            drawnow limitrate nocallbacks
        end
        fclose(tcpipServer);
        delete(tcpipServer);
        delete(ServerSend);
        ServerSend = [];

        if num == -1
            num = FramesZ;
        end
end

n_mc = 3;
n_mc_fld = 1;

nfr = get(handles.uibuttongroup8.SelectedObject,'String');
if strcmp (nfr, 'Mean')
    tts = uint16(mean(rawData, 3));
    h = handles.axes4;
    himage = imshow((tts), [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
    set(handles.slider1, 'Min', 1, 'Max', 1, 'Value', 1, ...
            'SliderStep', [0 0]);
    h.Toolbar.Visible = 'on';
    if mc == 1
        tts = uint16(tts);
        
        if AllignOnly == 0
            answer = questdlg('Use this image for Motion Correction?', ...
                'Options', ...
                'Yes','No', 'Yes');
            switch answer
                case 'Yes'
                    if fold == 0
                        [xcoord, ycoord] = ginput(n_mc);
                        vx = nan(n_mc, 1);
                        vy = nan(n_mc, 1);
                        for ixx = 1:size(xcoord)
                            vx(ixx, [1, 2]) = [round(xcoord(ixx) - 99), round(xcoord(ixx) + 99)];
                            vy(ixx, [1, 2]) = [round(ycoord(ixx) - 64), round(ycoord(ixx) + 63)];
                        end

                        if any(vx(:, 1) < 100)
                            idx = find(vx(:, 1) < 100);
                            vx(idx, 1) = 100; vx(idx, 2) = 298;
                        end
                        if any(vx(:, 2) > 794)
                            idx = find(vx(:, 2) > 794);
                            vx(idx, 1) = 596; vx(idx, 2) = 794;
                        end
                        if any(vy(:, 1) < 1)
                            idx = find(vy(:, 1) < 1);
                            vy(idx, 1) = 1; vy(idx, 2) = 128;
                        end
                        if any(vy(:, 2) > 510)
                            idx = find(vy(:, 2) > 510);
                            vy(idx, 1) = 383; vy(idx, 2) = 510;
                        end
                    else
                        [xcoord, ~] = ginput(n_mc);
                        vx = nan(n_mc, 1);
                        vy = nan(n_mc, 1);
                        
                        for ixx = 1:size(xcoord)
                            vx(ixx, [1, 2]) = [178, 535];
                            vy(ixx, [1, 2]) = [1, 60];
                        end
                    end
                case 'No'
                    vx = nan;
                    vy = nan;
            end
        elseif AllignOnly == 1
            vx = nan;
            vy = nan;
        end
    end

elseif strcmp (nfr, 'Max')
    tts = uint16(max(rawData,[], 3));
    h = handles.axes4;
    himage = imshow(tts, [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
    set(handles.slider1, 'Min', 1, 'Max', 1, 'Value', 1, ...
        'SliderStep', [0 0]);
%     h.Toolbar.Visible = 'on';
    if mc == 1
        tts = uint16(tts);
        vy = size(tts,2)/4;
        vx = size(tts,1)/4;
    end


elseif strcmp (nfr, 'Std')
    tts = uint16(std(rawData,0,3));
    h = handles.axes4;
    himage = imshow(tts, [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
    set(handles.slider1, 'Min', 1, 'Max', 1, 'Value', 1, ...
            'SliderStep', [0 0]);
%     h.Toolbar.Visible = 'on';
    if mc == 1
        tts = uint16(tts);
        vy = size(tts,2)/4;
        vx = size(tts,1)/4;
    end

    
elseif strcmp (nfr, 'All frames')
    tts= rawData;
    h = handles.axes4;
    himage = imshow(tts(:,:,1), [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
    set(himage, 'CData',tts(:,:,1));
    h.Toolbar.Visible = 'on';
    if num == -1
        set(handles.slider1, 'Min', 1, 'Max', size(tts,3), ...
            'SliderStep', [1 1]/(size(tts,3)-1), 'Value', 1);
    else
        set(handles.slider1, 'Min', 1, 'Max', num, ...
            'SliderStep', [1 1]/(num-1),  'Value', 1);
    end 
end
hold(handles.axes4, 'on')
handles.frameSlider = tts;
handles.nR = 0;
handles.stopROI = 0;
if isfield(handles, 'ROI')
    delete(handles.ROI);
end
guidata(hObject, handles);



% --- Executes on button press in pushbutton10.
function pushbutton10_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton10 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
answer = questdlg('Which ROI set do you want me to load?', ...
    'Options', ...
    'Last saved set','Manual load', 'Manual load');
directory = get(handles.edit11, 'String');
Folder = '\ROIs';
listing = dir([directory Folder '\*.mat']);
table = struct2table(listing); 
sortedT = sortrows(table, 'date');
sortedS = table2struct(sortedT);

switch answer
    case 'Last saved set'
        if sortedS(end).isdir == 0
            load([directory Folder '\' sortedS(end).name]);
        elseif sortedS(end).isdir == 1
            if sortedS(end - 1).isdir == 1
                load([directory Folder '\' sortedS(end-2).name]);
            elseif sortedS(end - 1).isdir == 0
                load([directory Folder '\' sortedS(end-1).name]);
            end
            
        end
    case 'Manual load'
        uiload
end
% pixelsX = 796;
% LinesY  = 512;
% h = handles.axes4;
% mask = cell(length(ROILoad.ROIpos),1);
% for iroi = 1:length(ROILoad.ROIpos)
%     tb = nan(pixelsX,LinesY);
%     for ix = 1:pixelsX
%         xq = repmat(ix, LinesY,1);
%         yq = [1:LinesY]';
%         tb(ix,:) = inpolygon(xq,yq, ROILoad.ROIpos(1,iroi).Position(:,1),...
%         ROILoad.ROIpos(1,iroi).Position(:,2));
%     end
%     mask{iroi,1} = tb;
%     [r, b] = find(mask{iroi, 1});
%     scatter(h, r, b);
%     hold(h, 'on')
% end

h = handles.axes4;
% colormap(h, gray);
hold (h, 'on')
for i = 1:numel(RoiInfo.ROIpos)
    handles.ROI(i) = drawpolygon(h, 'Position',RoiInfo.ROIpos(1,i).Position,...
        'LineWidth', 1, 'Deletable', true, 'Label', num2str(i), ...
        'LabelVisible', 'hover', 'Color', 'y', 'FaceAlpha', 0);
end
handles.nR = numel(handles.ROI);
handles.ROIdrawNum = length(listing);
guidata(hObject, handles);


% --- Executes on button press in pushbutton11.
function pushbutton11_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton11 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
h = handles.axes4;
handles.nR = handles.nR +1;
nR = handles.nR;
guidata(hObject, handles);
handles.ROI(nR) = drawpolygon(h, 'LineWidth', 1, 'Deletable', true, ...
    'Label', num2str(nR), 'LabelVisible', 'hover', 'Color', 'y', ...
    'FaceAlpha', 0);
guidata(hObject, handles);


% ROI = hObject.ROI;


% --- Executes on button press in pushbutton12.
function pushbutton12_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton12 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
handles.ROIdrawNum = handles.ROIdrawNum + 1;
guidata(hObject, handles);

isOk = isvalid(handles.ROI);
RoiInfo.ROIpos = handles.ROI(1,isOk);
subpop = str2num(get(handles.edit24, 'String')); %#ok<ST2NM>

if subpop ~= -1
    RoiInfo.subpop = subpop;
else
    RoiInfo.subpop = 1:length(RoiInfo.ROIpos);
end

RoiInfo.subpop = subpop;

directory = get(handles.edit11, 'String');
if strcmp('D:\Experiments\SessionName',directory)
    answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
    switch answer
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
end
Folder = '\ROIs';
nN = handles.ROIdrawNum;
filename = ['\' num2str(nN)];
if ~exist([directory Folder], 'dir')
    mkdir([directory Folder])
end
RoiInfo.dir = [directory Folder filename];
save([directory Folder filename], 'RoiInfo')

% --- Executes on button press in pushbutton7.
function pushbutton7_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton7 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on button press in pushbutton9.
function pushbutton9_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton9 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on button press in pushbutton8.
function pushbutton8_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton8 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function edit14_Callback(hObject, eventdata, handles)
% hObject    handle to edit14 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit14 as text
%        str2double(get(hObject,'String')) returns contents of edit14 as a double


% --- Executes during object creation, after setting all properties.
function edit14_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit14 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit15_Callback(hObject, eventdata, handles)
% hObject    handle to edit15 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit15 as text
%        str2double(get(hObject,'String')) returns contents of edit15 as a double


% --- Executes during object creation, after setting all properties.
function edit15_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit15 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit17_Callback(hObject, eventdata, handles)
% hObject    handle to edit17 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit17 as text
%        str2double(get(hObject,'String')) returns contents of edit17 as a double
val = str2double(get(hObject,'String'));

% --- Executes during object creation, after setting all properties.
function edit17_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit17 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit18_Callback(hObject, eventdata, handles)
% hObject    handle to edit18 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit18 as text
%        str2double(get(hObject,'String')) returns contents of edit18 as a double


% --- Executes during object creation, after setting all properties.
function edit18_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit18 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit19_Callback(hObject, eventdata, handles)
% hObject    handle to edit19 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit19 as text
%        str2double(get(hObject,'String')) returns contents of edit19 as a double


% --- Executes during object creation, after setting all properties.
function edit19_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit19 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function uibuttongroup8_ButtonDownFcn(hObject, eventdata, handles)
% Do Stuff



% --- Executes on slider movement.
function slider1_Callback(hObject, eventdata, handles)
% hObject    handle to slider1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider
% get(handles.slider1,'Value')
% 
% set(handles.slider1, 'Min', 1, 'Max', 1, ...
%         'SliderStep', [1 1]/1 - 1, 'Value', 1);

handles.index = get(hObject, 'Value');
if handles.slider1.Value > handles.slider1.Max || handles.slider1.Value < handles.slider1.Min
    handles.slider1.Value = handles.slider1.Min;
end
h = handles.axes4;

idx = handles.index;
if idx == 0
    idx = 1;
end
himage = imshow(handles.frameSlider(:,:,round(idx)), [], 'InitialMagnification', 800, 'Parent', h, 'border', 'tight');
set(himage, 'CData',handles.frameSlider(:,:,round(idx)));
h.Toolbar.Visible = 'on';

% pushbutton6_Callback(hObject, eventdata, handles)


% --- Executes during object creation, after setting all properties.
function slider1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to slider1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end
edit17_Callback(hObject, eventdata, handles)
set(hObject, 'Min', 1, 'Max', 1, 'Value', 1);





% --- Executes on button press in radiobutton13.
function radiobutton13_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton13 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% handles.axes4 = imshow(rand(200,200,3), [], 'InitialMagnification', 800);
% Hint: get(hObject,'Value') returns toggle state of radiobutton13


% --- Executes on button press in checkbox8.
function checkbox8_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox8 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox8



function edit20_Callback(hObject, eventdata, handles)
% hObject    handle to edit20 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit20 as text
%        str2double(get(hObject,'String')) returns contents of edit20 as a double


% --- Executes during object creation, after setting all properties.
function edit20_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit20 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit21_Callback(hObject, eventdata, handles)
% hObject    handle to edit21 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit21 as text
%        str2double(get(hObject,'String')) returns contents of edit21 as a double


% --- Executes during object creation, after setting all properties.
function edit21_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit21 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit22_Callback(hObject, eventdata, handles)
% hObject    handle to edit22 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit22 as text
%        str2double(get(hObject,'String')) returns contents of edit22 as a double


% --- Executes during object creation, after setting all properties.
function edit22_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit22 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in pushbutton14.
function pushbutton14_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton14 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA
% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Here we call some default settings for setting up Psychtoolbox

load('X:\home\annalb\spine_bci\2Pdata\gcamp_bci\gcampspinebci04\180124_gcampspinebci04\bci_metadata\Baseline\baselineMask_1.mat')
load('X:\home\annalb\spine_bci\2Pdata\gcamp_bci\gcampspinebci04\180124_gcampspinebci04\bci_metadata\ROIs\3.mat')
load('X:\home\annalb\spine_bci\2Pdata\gcamp_bci\gcampspinebci04\180124_gcampspinebci04\bci_metadata\BCI_Trials\1.mat')

frames_tmp_ = sbxgrabframe('X:\home\annalb\spine_bci\2Pdata\gcamp_bci\gcampspinebci04\180124_gcampspinebci04\180124_gcampspinebci04_000_003', 10146, 1);
frames_tmp_ = squeeze(frames_tmp_); 

h1 = handles.axes4;
imshow(frames_tmp_, 'Parent', h1)
for i = 1:numel(RoiInfo.ROIpos)
    if i == 1
        ROI(i) = drawpolygon(h1, 'Position',RoiInfo.ROIpos(1,i).Position,...
            'LineWidth', 1, 'Deletable', true, 'Label', num2str(i), ...
            'LabelVisible', 'hover', 'Color', 'r', 'FaceAlpha', 0);
    elseif sum(ismember(i, baseline.subpop2)) > 0
        ROI(i) = drawpolygon(h1, 'Position',RoiInfo.ROIpos(1,i).Position,...
            'LineWidth', 1, 'Deletable', true, 'Label', num2str(i), ...
            'LabelVisible', 'hover', 'Color', 'b', 'FaceAlpha', 0);
    end
end


h2 = handles.axes3;
plot(StimData.RoiPerFrame(1, 16560:16605),  rand(1, 10), 'Parent', h2)


% --- Executes on button press in pushbutton15.
function pushbutton15_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton15 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global tts vx vy 

hp = handles.axes4;
hp.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
hp.Toolbar = [];
colormap(hp, gray);

mc = get(handles.checkbox12,'Value');
if mc == 1
    fft_tts = nan(vy(1, 2) - vy(1, 1) + 1, vx(1, 2) - vx(1, 1) + 1, 3);
    % vx1 = [vx vx*2-1; vx vx*2-1; vx*2 vx*3-1; vx*2 vx*3-1];
    % vy1 = [vy vy*2-1; vy*2 vy*3-1; vy vy*2-1; vy*2 vy*3-1];
    
    vx1 = vy; %[vx vx*3-1; vx vx*3-1];
    vy1 = vx; %[vy vy*2-1; vy*2 vy*3-1];
    for i = 1:size(vx1,1)
        fft_tts(:,:,i) = fft2(tts(vx1(i,1):vx1(i,2), vy1(i,1):vy1(i,2)));
    end
%     fft_tts = uint16(fft_tts); 
end


pixelsX = str2double(get(handles.edit21,'string'));
LinesY  = str2double(get(handles.edit20,'string'));
FramesZ = str2double(get(handles.edit27,'string'));
oneTrial_length = str2double(get(handles.edit22,'string'));
fold = str2double(get(handles.edit30,'string'));
if fold ~= 0
    fold_fct = LinesY./fold;
end

answer = questdlg('Which ROI set do you want me to use to estimate Baseline?', ...
    'Options', 'Last saved set','Manual load', 'Manual load');
directory = get(handles.edit11, 'String');
Folder = '\ROIs';
listing = dir([directory Folder '\*.mat']);
lst = 0;
switch answer
    case 'Last saved set'
        load([directory Folder '\' listing(end).name]);
        lst =1;
    case 'Manual load'
        uiload
end

mask = cell(length(RoiInfo.ROIpos),1);
meanRoiOneFrame = nan(length(RoiInfo.ROIpos), FramesZ);

baseline.F0 = nan(length(RoiInfo.ROIpos), 1);
for iroi = 1:length(RoiInfo.ROIpos)
    tb = nan(LinesY, pixelsX);
    for ix = 1:LinesY
        yq = repmat(ix, pixelsX,1);
        xq = [1:pixelsX]';
        tb(ix,1:pixelsX) = inpolygon(xq, yq, RoiInfo.ROIpos(1,iroi).Position(:,1),...
        RoiInfo.ROIpos(1,iroi).Position(:,2));
    end
    mask{iroi,1} = logical(tb);
end

plane_num = str2double(get(handles.edit18,'string'));
plane_tot = str2double(get(handles.edit19,'string'));
frames_sampled = plane_num:plane_tot:(FramesZ*plane_tot);
baseline.Licks = nan(1, FramesZ);
baseline.Opto = nan(1, FramesZ);
baseline.timeStamp = nan(1, FramesZ);
baseline.angle = uint8(ones(1, FramesZ));
baseline.fwd_bkwd = uint8(repmat(11, 1, FramesZ));

baseline.ImTranslateXY = nan(2, FramesZ);

clear arduino
arduino = serialport('COM3', 9600);
flush(arduino);
fprintf('Connection established with Arduino\n')

Screen('Preference', 'SkipSyncTests', 1);
PsychDefaultSetup(2);
rand('seed', sum(100 * clock));

screenNumber = 2;%min(Screen('Screens'));

white = WhiteIndex(screenNumber);
grey = white / 2;
black = BlackIndex(screenNumber);
waitframes = 1;

% Open the screen
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);

Screen('Flip', window);
ifi = Screen('GetFlipInterval', window);

[xCenter, yCenter] = RectCenter(windowRect);

%--------------------
% Gabor information
%--------------------

% Dimensions
% gaborDimPix = 500;
gaborDimPixX = windowRect(3);
gaborDimPixY = windowRect(4);

% Sigma of Gaussian
sigma = gaborDimPixX/8 ;

% Obvious Parameters
orientation = 90;
contrast = 1;
aspectRatio = 1;

% Spatial Frequency (Cycles Per Pixel)
% One Cycle = Grey-Black-Grey-White-Grey i.e. One Black and One White Lobe
if ~isempty(get(handles.edit5,'string'))
    numCycles = str2double(get(handles.edit5,'string'));
else
    warning('Spatial Frequency automatically set to 5')
    numCycles = 5;
end
freq = numCycles / gaborDimPixX;

% Build a procedural gabor texture
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixY,...
    [], [0.5 0.5 0.5 1], 1, 10);

% Positions of the Gabors
dim = 8;
[x, y] = meshgrid(-dim:dim, -dim:dim);

% Calculate the distance in "Gabor numbers" of each gabor from the center
% of the array
dist = sqrt(x.^2 + y.^2);

% Cut out an inner annulus
innerDist = 3.5;
x(dist <= innerDist) = nan;
y(dist <= innerDist) = nan;

% Cut out an outer annulus
outerDist = 10;
x(dist >= outerDist) = nan;
y(dist >= outerDist) = nan;

% Select only the finite values
x = x(isfinite(x));
y = y(isfinite(y));

% Center the annulus coordinates in the centre of the screen
xPos = x .* gaborDimPixX + xCenter;
yPos = y .* gaborDimPixY + yCenter;

% Count how many Gabors there are
nGabors = numel(xPos);

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixY];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

% Drift speed for the 2D global motion
if ~isempty(get(handles.edit6,'string'))
    tFreq = str2double(get(handles.edit6,'string'));
else
    warning('Temporal Frequency automatically set to 2')
    tFreq = 2;
end
degPerSec = 360 * tFreq;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = 0; % rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = 0.5;% rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

waitframes = 1;

angles = 0:15:90;

if ~isempty(get(handles.edit4,'string'))
    tdrift = str2double(get(handles.edit4,'string'));
else
    tdrift = 1;
end

presTimeDrift = repmat(tdrift, 1, numel(angles));
% Animation loop
% while ~KbCheck

sent_data = 'a';
write(arduino,sent_data, 'char');

ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
    'OutputBufferSize', 12, 'Terminator', 'CR/LF');
fopen(ServerSend);
fwrite(ServerSend, uint32([(FramesZ*plane_tot)  plane_num  plane_tot]), 'uint32');
fclose(ServerSend);


% rawData = nan((pixelsX*LinesY),FramesZ);
tcpipServer = tcpip('10.93.6.2',30000,'NetworkRole','client', 'Terminator', 'CR/LF');
tcpipServer.InputBufferSize = (pixelsX*LinesY*200);
fopen(tcpipServer);

StimBaseline = get(handles.checkbox11,'Value');

Lucky_angle = 1:8;
Lucky_pick = 2;
count_lucks = 0;
n = 0; 
pl = 0;

imin = -0.5;
imx = 0.5;

while pl < FramesZ*plane_tot
    
    if StimBaseline == 1
        stm = 0;
        if (count_lucks == 0 || count_lucks == 3)
            count_lucks = 0;
            pick_angle = angles(randperm(length(angles),1));
            Lucky_pick  = Lucky_angle(randperm(length(Lucky_angle),1));
            fwd_bkwd = randi([1, 2], 1);
            if pick_angle > 70 && Lucky_pick == 1 && fwd_bkwd == 1
                pick_angle = 60;
            elseif pick_angle < 20 && Lucky_pick == 1 && fwd_bkwd == 2
                pick_angle = 30;
            end
        elseif (count_lucks > 0 && count_lucks < 3)
            if fwd_bkwd == 1
                pick_angle = pick_angle + 15;
            elseif fwd_bkwd == 2
                pick_angle = pick_angle - 15;
            end
        end
        timerVal = tic;
        trand = imin + (imx-imin).*rand;
        while toc(timerVal) < tdrift + trand
            
            pl = pl+1;
            if pl > FramesZ*plane_tot
                break
            end
            rawData = fread(tcpipServer,(pixelsX*LinesY),'uint16');
            
            if sum(ismember(pl, frames_sampled)) == 0
                continue
            end
            
            n = n + 1;
            stm = stm + 1;
            if n == 1
                timeStamp = tic;
                rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
                rawData_tmp = permute(rawData_tmp, [2 1]);
                rawData_tmp = imcomplement(rawData_tmp);
                if fold ~= 0
                    rawData_tmp = reshape(rawData_tmp, pixelsX, fold, fold_fct);
                    rawData_tmp = uint16(mean(rawData_tmp, 3));
                end
                hp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hp, 'border', 'tight');
            end
            rawData = reshape(uint16(rawData), pixelsX, LinesY);
            rawData = permute(rawData, [2 1]);
            rawData = imcomplement(rawData);
            if fold ~= 0       
                r_tmp = uint16(zeros(fold, pixelsX, fold_fct));
                for ifc = 1:fold_fct %#ok<BDSCI>
                    fuck_index = (fold*(ifc-1))+ 1 : fold*ifc;
                    r_tmp(:, :, ifc) = rawData(fuck_index, :, 1);
                end
                rawData = uint16(mean(r_tmp, 3));
            end
            
            if mc == 1
                output = nan(3, 4);
                for i = 1:size(fft_tts, 3)
                    output(i,:) = dftregistration(fft_tts(:,:,i), fft2(double(rawData(vx1(i,1):vx1(i,2), vy1(i,1):vy1(i,2)))));
                end
                xsh = round(nanmedian(output(:,4)));
                ysh = round(nanmedian(output(:,3)));
                rawData = imtranslate(rawData, [xsh ysh]);
                baseline.ImTranslateXY(:, n)  = [xsh; ysh];

            end
            
            for iroi = 1:length(mask)
                meanRoiOneFrame(iroi,n) = nanmean(rawData(mask{iroi,1}));
            end
            
            set(hp, 'CData', im2uint16(rawData));
            try
                drawnow limitrate nocallbacks
            catch
                warning('Could not plot')
            end
            
            if stm == 1
                Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');
                % Draw texture
                Screen('DrawTexture', window, gabortex, [], [], pick_angle,...
                    [], [], [], [], kPsychDontDoRotation, propertiesMat');
                Screen('Flip', window, 0, 1);
            end
            %Screen('Flip', window);
            %
            baseline.timeStamp(n) = toc(timeStamp);
            baseline.angle(n) = uint8(pick_angle);
            if Lucky_pick == 1
                baseline.fwd_bkwd(n) = uint8(fwd_bkwd);
            else
                baseline.fwd_bkwd(n) = uint8(0);
            end
            try
                if handles.radiobutton24.Value == 1
                    sent_data = 'c';
%                     baseline.Reward_frames(n) = 0;
                    baseline.Opto(n) = 1;
                    write(arduino,sent_data, 'char');
                end
                baseline.Licks(n)  = read(arduino, 1, 'uint8');
                flush(arduino, 'input');
            catch
                clear arduino
                arduino = serialport('COM3', 9600);
                ard = 0;
                disp('Connection with Arduino re-established')
                if handles.radiobutton24.Value == 1
                    sent_data = 'c';
%                     baseline.Reward_frames(n) = 0;
                    baseline.Opto(n) = 1;
                    write(arduino,sent_data, 'char');
                end
                baseline.Licks(n)  = baseline.Licks(n-1) - 1;
%                 warning ('No Info From Arduino')
            end
        end
        if Lucky_pick == 1
            count_lucks = count_lucks + 1;
        end
        
    elseif StimBaseline == 0
        pl = pl+1;
        if pl > FramesZ*plane_tot
            break
        end
        rawData = fread(tcpipServer,(pixelsX*LinesY),'uint16');

        if sum(ismember(pl, frames_sampled)) == 0
            continue
        end

        n = n + 1;
        if n == 1
            timeStamp = tic;
            rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
            rawData_tmp = permute(rawData_tmp, [2 1]);
            rawData_tmp = imcomplement(rawData_tmp);
            if fold ~= 0
                rawData_tmp = reshape(rawData_tmp, pixelsX, fold, fold_fct);
                rawData_tmp = uint16(mean(rawData_tmp, 3));
            end
            hp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hp, 'border', 'tight');
        end
        rawData = reshape(uint16(rawData), pixelsX, LinesY);
        rawData = permute(rawData, [2 1]);
        rawData = imcomplement(rawData);
        if fold ~= 0
            r_tmp = uint16(zeros(fold, pixelsX, fold_fct));
            for ifc = 1:fold_fct %#ok<BDSCI>
                fuck_index = (fold*(ifc-1))+ 1 : fold*ifc;
                r_tmp(:, :, ifc) = rawData(fuck_index, :, 1);
            end
            rawData = uint16(mean(r_tmp, 3));
        end

        if mc == 1
            output = nan(3, 4);
            for i = 1:size(fft_tts, 3)
                output(i,:) = dftregistration(fft_tts(:,:,i), fft2(double(rawData(vx1(i,1):vx1(i,2), vy1(i,1):vy1(i,2)))));
            end
            xsh = round(nanmedian(output(:,4)));
            ysh = round(nanmedian(output(:,3)));
            rawData = imtranslate(rawData, [xsh ysh]);
            baseline.ImTranslateXY(:, n)  = [xsh; ysh];
        end

        for iroi = 1:length(mask)
            meanRoiOneFrame(iroi,n) = nanmean(rawData(mask{iroi,1}));
        end

        set(hp, 'CData', im2uint16(rawData));
        try
            drawnow limitrate nocallbacks
        catch
            warning('Could not plot')
        end

        Screen('FillRect', window, [0 0 0]);
        Screen('Flip', window, 0, 1);


        baseline.timeStamp(n) = toc(timeStamp);
        baseline.angle(n) = uint8(0);
        

        try
            baseline.Licks(n)  = read(arduino, 1, 'uint8');
            flush(arduino, 'input');
        catch
            baseline.Licks(n)  = baseline.Licks(n-1) - 1;
            warning ('No Info From Arduino')
        end
    end
end

%clean up
sca;

fclose(tcpipServer);

delete(tcpipServer);
delete(ServerSend);
ServerSend = [];

meanRoiOneFrame = double(meanRoiOneFrame);


figure(1)
for i = 1:size(meanRoiOneFrame, 1)
    plot(meanRoiOneFrame(i,:)./max(meanRoiOneFrame(i,:)) + i, 'k')
    hold on
end
hold off
disp('Press Any Button to Continue')

try
    pause
catch
    pause
end

subPopulations = inputdlg({'SubPop1 [x:n,y,z]','SubPop2 [x:n,y,z]'},...
              'ROI Selection', [1 35; 1 35]); 

close figure 1

sp1 = str2num(subPopulations{1});
sp2 = str2num(subPopulations{2});
subpop1_2 = cat(2, sp1, sp2);
RoiInfo.ROIpos = RoiInfo.ROIpos(subpop1_2);

RoiInfo.subpop = 1:length(sp1);
RoiInfo.subpop2 = length(sp1)+1:length(sp1)+length(sp2);
save(RoiInfo.dir, 'RoiInfo');

baseline.subpop1 = RoiInfo.subpop;
baseline.subpop2 = RoiInfo.subpop2;


Roi_s1 = meanRoiOneFrame(sp1, :);
Roi_s2 = meanRoiOneFrame(sp2, :);
meanRoiOneFrame = cat(1, Roi_s1, Roi_s2);

hp = handles.axes4;
himage = imshow(uint16(tts), [], 'InitialMagnification', 800, 'Parent', hp, 'border', 'tight');
set(handles.slider1, 'Min', 1, 'Max', 1, 'Value', 1, ...
    'SliderStep', [0 0]);
hold (hp, 'on')
for i = 1:numel(RoiInfo.ROIpos)
    if sum(ismember(i, baseline.subpop1)) > 0
        handles.ROI(i) = drawpolygon(hp, 'Position',RoiInfo.ROIpos(1,i).Position,...
            'LineWidth', 1, 'Deletable', true, 'Label', num2str(i), ...
            'LabelVisible', 'hover', 'Color', 'r', 'FaceAlpha', 0);
    elseif sum(ismember(i, baseline.subpop2)) > 0
        handles.ROI(i) = drawpolygon(hp, 'Position',RoiInfo.ROIpos(1,i).Position,...
            'LineWidth', 1, 'Deletable', true, 'Label', num2str(i), ...
            'LabelVisible', 'hover', 'Color', 'g', 'FaceAlpha', 0);
    end
end
% guidata(hObject, handles.ROI);

% baseline.fullrec = rawData;
baseline.mean = mean(meanRoiOneFrame,2);
baseline.std  = std(meanRoiOneFrame,0,2);
baseline.roiData = meanRoiOneFrame;
baseline.roiMask = mask(subpop1_2); 
baseline.nroi = length(RoiInfo.ROIpos);
baseline.stimBaseline = StimBaseline;

if lst == 1
    baseline.roiFile = [directory Folder '\' listing(end).name];
elseif lst ==0
    baseline.roiFile = 'Manual Pick';
end

if StimBaseline
    indx = baseline.fwd_bkwd == 0 & baseline.angle > 10 & baseline.angle < 80;
    baseline.ExcludeIndx = indx;
else
    indx = true(1, size(meanRoiOneFrame, 2));
    baseline.ExcludeIndx = [];
end
% indx = baseline.fwd_bkwd == 11 ;


trial_start = randperm(size(baseline.roiData(:, indx),2), 200);
df_oneTrial  = cell(1, length(trial_start));
z_zz = cell(1, length(trial_start));
F0_all = cell(1, length(trial_start));
F_2 = repmat(baseline.roiData(:, indx), 1, 2); 
F0_tmp = nan(size(baseline.roiData(:, indx)));

for i = 1:size(baseline.roiData(:, indx), 2)
    F0_tmp(:,i) = prctile(F_2(:,i:i+(oneTrial_length*4)-1), 10, 2);
end
F0_tmp= (repmat(F0_tmp, 1, 2));

for itrial = 1:length(trial_start)
    beg_end = [trial_start(itrial)+size(baseline.roiData(:, indx),2)-749; ...
        trial_start(itrial)+size(baseline.roiData(:, indx),2)];
    
    F0_all{itrial} = F0_tmp(:,beg_end(1):beg_end(2));
    df_oneTrial{itrial} =  (F_2(:, trial_start(itrial) : trial_start(itrial) + 749)-F0_all{itrial})./F0_all{itrial};
    if ~isempty(baseline.subpop2)
        z_zz{itrial}= nanmean(df_oneTrial{itrial}(baseline.subpop1, :),1) - nanmean(df_oneTrial{itrial}(baseline.subpop2,:),1);
    else
        z_zz{itrial}= nanmean(df_oneTrial{itrial},1);
    end
end

if ~isempty(baseline.subpop2)
    dfmx1 = max(cat(2, z_zz{:}));
    dfmx2 = min(cat(2, z_zz{:}));
    threshs = dfmx2: 0.005: dfmx1;  
else
    threshs = 0:0.01:max(df, [], 'all');
end

baseline.zzz = z_zz;
Day = str2double(get(handles.edit29,'string'));
if Day == 1
    asw = questdlg('Is this really Day 1?');
    switch asw
        case 'Yes'
            dayy1 = 1;
        case 'No'
            dayy1 = 0;
    end
else
    asw = questdlg('Are you sure this IS NOT day 1?');
    switch asw
        case 'Yes'
            dayy1 = 0;
        case 'No'
            dayy1 = 1;
    end
end

if dayy1 == 1
    propp = nan(1,length(threshs));
    for i = 1:length(threshs)
        total_large = nan(1,length(z_zz));
        for ii =  1:length(z_zz)
            mvMu = movmean(z_zz{ii}, 3);
            %         mvMu = z_zz{ii};
            if sum(mvMu > threshs(i)) > 0
                total_large(ii) = 1;
            else
                total_large(ii) = 0;
            end
        end
        propp(1,i) = sum(total_large)/length(total_large);
        propp(2,i) = threshs(i);
    end
    baseline.propTrialsTresh = propp;
    Thresh.propTrialsTresh = baseline.propTrialsTresh;
    baseline.selected_tresh = propp(2,min(find(propp(1,:) <= 0.5)));
    [muFit, sigmaFit] = normfit(cat(2, z_zz{:}));
    baseline.muFit = muFit;
    baseline.sigmaFit = sigmaFit;
    Thresh.muFit = muFit;
    Thresh.sigmaFit = sigmaFit;
    z_sc = (baseline.selected_tresh - muFit)/sigmaFit;
    % baseline.selected_range = muFit - (z_sc*sigmaFit);
    baseline.selected_range = min(cat(2, z_zz{:}));
    
    cc =  cat(2, baseline.zzz{:});
    % Data on the left side of the distribution
    d = cc(cc <= nanmedian(cc));
    % Mirror the distribution on the right
    dd = max(d)-d;
    %concatenate the left and right side of the distribution
    ddc = cat(2,d, dd);
    %fit
    [baseline.muHalfFit, baseline.sigmaHalfFit] = normfit(ddc);
    % z score
    baseline.z_HalfFit = (baseline.selected_tresh - baseline.muHalfFit)/baseline.sigmaHalfFit;
    
elseif dayy1 ~= 1
    
    propp = nan(1,length(threshs));
    for i = 1:length(threshs)
        total_large = nan(1,length(z_zz));
        for ii =  1:length(z_zz)
            mvMu = movmean(z_zz{ii}, 3);
            %         mvMu = z_zz{ii};
            if sum(mvMu > threshs(i)) > 0
                total_large(ii) = 1;
            else
                total_large(ii) = 0;
            end
        end
        propp(1,i) = sum(total_large)/length(total_large);
        propp(2,i) = threshs(i);
    end
    selected_tresh = propp(2,min(find(propp(1,:) <= 0.5)));
    [muFit, sigmaFit] = normfit(cat(2, z_zz{:}));
    z_sc = (selected_tresh - muFit)/sigmaFit;
    selected_range = min(cat(2, z_zz{:}));
    
    cc_2 =  cat(2, baseline.zzz{:});
    % Data on the left side of the distribution
    d_2 = cc_2(cc_2 <= nanmedian(cc_2));
    % Mirror the distribution on the right
    dd_2 = max(d_2)-d_2;
    %concatenate the left and right side of the distribution
    ddc_2 = cat(2,d_2, dd_2);
    %fit
    [muHalfFit, sigmaHalfFit] = normfit(ddc_2);
    % z score
    z_HalfFit = (selected_tresh - muHalfFit)/sigmaHalfFit;
    
    uiload
    
    if Thresh.z_HalfFit >= z_HalfFit
        baseline.z_HalfFit = z_HalfFit;
        baseline.selected_tresh = selected_tresh;
        baseline.selected_range = selected_range;
        baseline.muHalfFit = muHalfFit;
        baseline.sigmaHalfFit = sigmaHalfFit;
        disp ('Using today baseline')
    else
        cc =  cat(2, baseline.zzz{:});
        % Data on the left side of the distribution
        d = cc(cc <= nanmedian(cc));
        % Mirror the distribution on the right
        dd = max(d)-d;
        %concatenate the left and right side of the distribution
        ddc = cat(2,d, dd);
        %fit
        [baseline.muHalfFit, baseline.sigmaHalfFit] = normfit(ddc);
        baseline.z_HalfFit = Thresh.z_HalfFit;
        baseline.selected_tresh = baseline.muHalfFit + (baseline.sigmaHalfFit*Thresh.z_HalfFit);
        baseline.selected_range = min(cat(2, z_zz{:}));
        disp ('Using uploaded baseline')
    end
end

baseline.F_all = F0_all;
for iroi = 1:size(baseline.roiData,1)
    baseline.F0(iroi,1) = prctile(meanRoiOneFrame(iroi,end-869:end), 10);
end

baseline.RefImage = tts;

Thresh.selected_tresh = baseline.selected_tresh;
Thresh.selected_range = baseline.selected_range;
Thresh.z_HalfFit = baseline.z_HalfFit; 

baseline.plane_num = plane_num; 
baseline.plane_tot = plane_tot;

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
elseif saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
    currentCounterValue = str2double(get(handles.edit10, 'String'));
    % Create a new string with the number being 1 more than the current number.
    newString = sprintf('%d', int32(currentCounterValue +1));
    % Send the new string to the text control.
    set(handles.edit10, 'String', newString );
    %     directory = get(handles.edit11, 'String');
    Folder = '\Baseline';
    filename1 = ['\baselineMask_' num2str(currentCounterValue)];
    filename2 = ['\Threshold_values' num2str(currentCounterValue)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename1], 'baseline')
    save([directory Folder filename2], 'Thresh')
end
% --- Executes on button press in checkbox9.

function checkbox9_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox9 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox9


% --- Executes on button press in checkbox10.
function checkbox10_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox10 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox10



function edit23_Callback(hObject, eventdata, handles)
% hObject    handle to edit23 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit23 as text
%        str2double(get(hObject,'String')) returns contents of edit23 as a double


% --- Executes during object creation, after setting all properties.
function edit23_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit23 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in radiobutton16.
function radiobutton16_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton16 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton16


% --- Executes on button press in radiobutton17.
function radiobutton17_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton17 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton17


% --- Executes on button press in radiobutton18.
function radiobutton18_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton18 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton18


% --- Executes on button press in radiobutton20.
function radiobutton20_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton20 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton20


% --- Executes on button press in radiobutton21.
function radiobutton21_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton21 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton21


% --- Executes when selected object is changed in uibuttongroup4.
function uibuttongroup4_SelectionChangedFcn(hObject, eventdata, handles)
% hObject    handle to the selected object in uibuttongroup4 
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function edit24_Callback(hObject, eventdata, handles)
% hObject    handle to edit24 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit24 as text
%        str2double(get(hObject,'String')) returns contents of edit24 as a double


% --- Executes during object creation, after setting all properties.
function edit24_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit24 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in pushbutton16.
function pushbutton16_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton16 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
hpp = handles.axes4;
hpp.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
hpp.Toolbar = [];
colormap(hpp, gray);

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
end
directory = get(handles.edit11, 'String');
if saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
end

pixelsX = str2double(get(handles.edit21,'string'));
LinesY  = str2double(get(handles.edit20,'string'));
FramesZ = str2double(get(handles.edit22,'string'));

answer = questdlg('Which ROI set do you want me to use to estimate Baseline?', ...
    'Options', 'Last saved set','Manual load', 'Manual load');
directory = get(handles.edit11, 'String');
Folder = '\ROIs';
listing = dir([directory Folder '\*.mat']);
lst = 0;
switch answer
    case 'Last saved set'
        load([directory Folder '\' listing(end).name]);
        lst =1;
    case 'Manual load'
        uiload
end

mask = cell(length(RoiInfo.ROIpos),1);
% meanRoiOneFrame = nan(length(RoiInfo.ROIpos), FramesZ);
% baseline.F0 = nan(length(RoiInfo.ROIpos), 1);
for iroi = 1:length(RoiInfo.ROIpos)
    tb = nan(LinesY, pixelsX);
    for ix = 1:LinesY
        yq = repmat(ix, pixelsX,1);
        xq = [1:pixelsX]';
        tb(ix,1:pixelsX) = inpolygon(xq, yq, RoiInfo.ROIpos(1,iroi).Position(:,1),...
        RoiInfo.ROIpos(1,iroi).Position(:,2));
    end
    mask{iroi,1} = logical(tb);
end
roiMask = mask;
nroi = length(RoiInfo.ROIpos);

n = 0;

AngleNumb = str2double(get(handles.uibuttongroup1.SelectedObject,'String'));
if AngleNumb == 8
    angles = 0:45:315;
elseif AngleNumb == 12
    angles = 0:30:330;
end

if get(handles.checkbox6,'Value') == 1
    blduration  = str2double(get(handles.edit3, 'String'));
end
if get(handles.checkbox2,'Value') == 1
    drduration  = str2double(get(handles.edit4, 'String'));
end
if get(handles.checkbox3,'Value') == 1
    grduration  = str2double(get(handles.edit2, 'String'));
end


rsmpl  = 1;
numCycles = str2double(get(handles.edit5, 'String'));
if isnan(numCycles)
    numCycles = 4;
end
% Stim.SpFreq = numCycles;


% Stimulus presentation
PsychDefaultSetup(2);
screenNumber = 2;%min(Screen('Screens'));
% Screen('Preference', 'SkipSyncTests', 1);

white = WhiteIndex(screenNumber);
grey = white / 2;
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);
Screen('Flip', window);

ifi = Screen('GetFlipInterval', window);
topPriorityLevel = MaxPriority(window);


gaborDimPixX = 400;
% Stim.GaborSz = gaborDimPixX;
% Stim.type = 'Gabor';

sigma = gaborDimPixX / 10;
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixX,...
    [], [0.5 0.5 0.5 0], 1, 100);

xPos = windowRect(3)/8:windowRect(3)/4:windowRect(3);
yPos = windowRect(4)/6:windowRect(4)/3:windowRect(4);
xPos = repmat(xPos, 1, numel(yPos));
xPos = sort(xPos);
yPos = repmat(yPos, 1, numel(xPos)/numel(yPos));
% Count how many Gabors there are
nGabors = numel(xPos);

% Stim.NGabor = rsmpl;

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixX];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

contrast = 1;
aspectRatio = 1;
freq = numCycles / gaborDimPixX;

tFreq = str2double(get(handles.edit6, 'String'));
degPerSec = 360 * tFreq;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

vbl = Screen('Flip', window);

waitframes = 1;

loop = 0;

trig = get(handles.checkbox9,'Value');
% l = 1;
% loops = str2double(get(handles.edit2, 'String'));
% Stim.Loops = loops;

RandStream('dsfmt19937');

% y = datasample(1:loops,loops, 'Replace', false);
% p = str2double(get(handles.edit5, 'String'));
% nv = loops*(p/100);
% idx  = find(y <= nv);
% angles(idx, 2) = -1;
roi_one_frame = nan(nroi,FramesZ);
roi_resp = nan(nroi, 500);
x_y_gabor_coord = nan(1, 500);

ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
    'OutputBufferSize', 2, 'Terminator', 'CR/LF');
fopen(ServerSend);
fwrite(ServerSend, uint16(FramesZ), 'uint16');
fclose(ServerSend);

tcpipServer = tcpip('10.93.6.2',30000,'NetworkRole','client', 'Terminator', 'CR/LF');
tcpipServer.InputBufferSize = (pixelsX*LinesY*10);
fopen(tcpipServer);

Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');

while n <= FramesZ
    
    loop = loop+1;

    angles = datasample(angles, numel(angles), 'Replace', false);
    rnd_idx = datasample(1:size(allRects,2), rsmpl , 'Replace', false);
    rnd_gabors = allRects(:, rnd_idx);
    
    tb  = tic;
    cb = 0;
    while toc(tb) < blduration
        n = n+1;
        if n > FramesZ
            break
        end
        rawData = uint16(fread(tcpipServer,(pixelsX*LinesY),'uint16'));
        rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
        rawData_tmp = permute(rawData_tmp, [2 1]);
        rawData_tmp = imcomplement(rawData_tmp);
        if n == 1
            hpp = image(im2uint16(rawData_tmp)); %, [], 'InitialMagnification', 800, 'Parent', hpp, 'border', 'tight');
        end
        set(hpp, 'CData',im2uint16(rawData_tmp));
        drawnow limitrate nocallbacks
        
        for ii = 1:nroi
            roi_one_frame(ii,n) = double(mean(rawData_tmp(roiMask{ii, 1})));
        end
        cb = cb + 1;
        if cb == 1
            Screen('FillRect', window, [0 0 0]);
            Screen('Flip', window, 0, 1);
        end
    end
    
    tg  = tic;
    cg = 0;
    while toc(tg) < grduration
        n = n+1;
        if n > FramesZ
            break
        end
        rawData = uint16(fread(tcpipServer,(pixelsX*LinesY),'uint16'));
        rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
        rawData_tmp = permute(rawData_tmp, [2 1]);
        rawData_tmp = imcomplement(rawData_tmp);
        for ii = 1:nroi
            roi_one_frame(ii,n) = double(mean(rawData_tmp(roiMask{ii, 1})));
        end
        if n == 1
            % hpp = image(im2uint8(rawData_tmp)); 
            hpp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hpp, 'border', 'tight');
        end
        set(hpp, 'CData',im2uint16(rawData_tmp));
        drawnow limitrate nocallbacks
        
       
        cg = cg + 1;
        if cg == 1
            Screen('FillRect', window, [0.5 0.5 0.5]);
            Screen('Flip', window, 0, 1);
        end
    end
    
    count = 0;
    for i = 1: size(angles, 2)
        timerval = tic;
        count = count +1;
        if count == 1
            n_start  = n;
        end
        while toc(timerval) < drduration
            n = n+1;
            if n > FramesZ
                break
            end
            rawData = uint16(fread(tcpipServer,(pixelsX*LinesY),'uint16'));
            rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
            rawData_tmp = permute(rawData_tmp, [2 1]);
            rawData_tmp = imcomplement(rawData_tmp);
            for ii = 1:nroi
                roi_one_frame(ii,n) = double(mean(rawData_tmp(roiMask{ii, 1})));
            end
            
            if n == 1
                % hpp = image(im2uint8(rawData_tmp)); 
                hpp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hpp, 'border', 'tight');
            end
            set(hpp, 'CData',im2uint16(rawData_tmp));
            drawnow limitrate nocallbacks
            
            Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');
            Screen('DrawTextures', window, gabortex, [], rnd_gabors, angles(i), ...
                [], [], [], [], kPsychDontDoRotation, propertiesMat(rnd_idx, :)');
            Screen('Flip', window);%, vbl + (waitframes - 0.5) * ifi);
            % Increment the phase of our Gabors
            phaseLine = phaseLine + degPerFrameGabors;
            propertiesMat(:, 1) = phaseLine';
        end
    end
    if n > FramesZ
        n_end = FramesZ;
    else
        n_end = n;
    end
    roi_resp(:, loop) = nanmean(roi_one_frame(:, n_start:n_end), 2);
    x_y_gabor_coord(:, loop) = rnd_idx;
end

F0 = nan(size(roi_one_frame, 1), 1);
for iroi = 1:size(roi_one_frame, 1)
    F0(iroi,1) = double(prctile(roi_one_frame(iroi,:), 10));
end
df = (roi_resp -F0)./F0;

retinotopy.df = df; retinotopy.F0 = F0; retinotopy.gabor = allRects;
retinotopy.roi_F = roi_resp; retinotopy.idx_gabor = x_y_gabor_coord;

cla(handles.axes3);
hp = handles.axes3;
hp.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
hp.Toolbar = [];
resp = nan(1, size(retinotopy.gabor, 2));
err = nan(1, size(retinotopy.gabor, 2));
single_neuron_resp = nan(size(df, 1), size(retinotopy.gabor, 2)); 

for i = 1:size(retinotopy.gabor, 2)
    all_resp_one_patch = retinotopy.df(:, retinotopy.idx_gabor == i);
    resp(i) = nanmean(all_resp_one_patch, 'all');
    err(i) = std(nanmean(all_resp_one_patch, 2))/sqrt(size(all_resp_one_patch, 1));
    single_neuron_resp(:, i) = nanmean(all_resp_one_patch, 2);
    scatter(hp, repmat(i, 1, size(all_resp_one_patch, 1)), single_neuron_resp(:, i), 'k', 'Filled')
    hold (hp, 'on')
end
bar(hp,resp, 'r', 'FaceAlpha',0.3)
hold on
errorbar(hp, resp,err, 'k', 'LineWidth', 2, 'LineStyle','none')
retinotopy.meanResp = resp;
retinotopy.SEM = err;
retinotopy.all_resp_perGabor = single_neuron_resp;

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
elseif saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
    currentCounterValue = str2double(get(handles.edit10, 'String'));
    newString = sprintf('%d', int32(currentCounterValue +1));
    set(handles.edit10, 'String', newString );
    Folder = '\Retinotopy';
    filename1 = ['\retinotopy_' num2str(currentCounterValue)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename1], 'retinotopy')
end

sca;


% --- Executes on button press in pushbutton17.
function pushbutton17_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton17 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
answer = questdlg('Which Retinotopy data do you want me to load?', ...
    'Options', ...
    'Last saved set','Manual load', 'Manual load');
directory = get(handles.edit11, 'String');
Folder = '\Retinotopy';
listing = dir([directory Folder '\*.mat']);
table = struct2table(listing); 
sortedT = sortrows(table, 'date');
sortedS = table2struct(sortedT);

switch answer
    case 'Last saved set'
        if sortedS(end).isdir == 0
            load([directory Folder '\' sortedS(end).name]);
        elseif sortedS(end).isdir == 1
            if sortedS(end - 1).isdir == 1
                load([directory Folder '\' sortedS(end-2).name]);
            elseif sortedS(end - 1).isdir == 0
                load([directory Folder '\' sortedS(end-1).name]);
            end
            
        end
    case 'Manual load'
        uiload
end

cla(handles.axes3);
hp = handles.axes3;
for i = 1:size(retinotopy.all_resp_perGabor,2)
    scatter(hp, repmat(i, 1, size(retinotopy.all_resp_perGabor, 1)), ...
        retinotopy.all_resp_perGabor(:, i), 'k', 'Filled')
    hold (hp, 'on')
end
bar(hp,retinotopy.meanResp, 'r', 'FaceAlpha',0.3)
hold on
errorbar(hp, retinotopy.meanResp, retinotopy.SEM, 'k', 'LineWidth', 2, 'LineStyle','none')





function edit25_Callback(hObject, eventdata, handles)
% hObject    handle to edit25 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit25 as text
%        str2double(get(hObject,'String')) returns contents of edit25 as a double


% --- Executes during object creation, after setting all properties.
function edit25_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit25 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in pushbutton18.
function pushbutton18_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton18 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
clear arduino
arduino = serialport('COM3', 9600);
flush(arduino);
fprintf('Connection established with Arduino\n')


hp = handles.axes4;
hp.Interactions = [zoomInteraction regionZoomInteraction rulerPanInteraction];
hp.Toolbar = [];
colormap(hp, gray);

pixelsX = str2double(get(handles.edit21,'string'));
LinesY  = str2double(get(handles.edit20,'string'));
FramesZ = str2double(get(handles.edit27,'string'));

directory = get(handles.edit11, 'String');
listing = dir([directory '\Baseline\']);
table = struct2table(listing); 
sortedT = sortrows(table, 'date');
sortedS = table2struct(sortedT);
if sortedS(end).isdir == 0
    load([directory '\Baseline\' sortedS(end).name]);
    bline_loaded = [directory '\Baseline\' sortedS(end).name];
elseif sortedS(end).isdir == 1
    if sortedS(end - 1).isdir == 1
        load([directory '\Baseline\' sortedS(end-2).name]);
        bline_loaded = [directory '\Baseline\' sortedS(end-2).name];
    elseif sortedS(end - 1).isdir == 0
        load([directory '\Baseline\' sortedS(end-1).name]);
        bline_loaded = [directory '\Baseline\' sortedS(end-1).name];
    end
end
if isfield(baseline, 'fullrec')
    baseline = rmfield(baseline, 'fullrec');
end
F0 = double(baseline.F0);
subpop1 = baseline.subpop1;
subpop2 = baseline.subpop2;
nroi = baseline.nroi;

mask = baseline.roiMask;
plane_num = str2double(get(handles.edit18,'string'));
plane_tot = str2double(get(handles.edit19,'string'));
frames_sampled = plane_num:plane_tot:(FramesZ*plane_tot);

meanRoiOneFrame = nan(nroi, FramesZ);

rotating_drift.timeStamp = nan(1, FramesZ);
rotating_drift.angle = uint8(ones(1, FramesZ));
rotating_drift.fwd_bkwd = uint8(repmat(11, 1, FramesZ));
rotating_drift.Licks = uint8(ones(1, FramesZ*plane_tot));

Screen('Preference', 'SkipSyncTests', 1);
PsychDefaultSetup(2);
rand('seed', sum(100 * clock));

screenNumber = 2;%min(Screen('Screens'));

white = WhiteIndex(screenNumber);
grey = white / 2;
black = BlackIndex(screenNumber);
waitframes = 1;

% Open the screen
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, grey, [], 32, 2,...
    [], [],  kPsychNeed32BPCFloat);

Screen('Flip', window);
ifi = Screen('GetFlipInterval', window);

[xCenter, yCenter] = RectCenter(windowRect);

%--------------------
% Gabor information
%--------------------

% Dimensions
% gaborDimPix = 500;
gaborDimPixX = windowRect(3);
gaborDimPixY = windowRect(4);

% Sigma of Gaussian
sigma = gaborDimPixX ;

% Obvious Parameters
orientation = 90;
contrast = 1;
aspectRatio = 1;

% Spatial Frequency (Cycles Per Pixel)
% One Cycle = Grey-Black-Grey-White-Grey i.e. One Black and One White Lobe
if ~isempty(get(handles.edit5,'string'))
    numCycles = str2double(get(handles.edit5,'string'));
else
    warning('Spatial Frequency automatically set to 5')
    numCycles = 5;
end
freq = numCycles / gaborDimPixX;

% Build a procedural gabor texture
gabortex = CreateProceduralGabor(window, gaborDimPixX, gaborDimPixY,...
    [], [1 1 1 0.5], 1, 100);

% Positions of the Gabors
dim = 8;
[x, y] = meshgrid(-dim:dim, -dim:dim);

% Calculate the distance in "Gabor numbers" of each gabor from the center
% of the array
dist = sqrt(x.^2 + y.^2);

% Cut out an inner annulus
innerDist = 3.5;
x(dist <= innerDist) = nan;
y(dist <= innerDist) = nan;

% Cut out an outer annulus
outerDist = 10;
x(dist >= outerDist) = nan;
y(dist >= outerDist) = nan;

% Select only the finite values
x = x(isfinite(x));
y = y(isfinite(y));

% Center the annulus coordinates in the centre of the screen
xPos = x .* gaborDimPixX + xCenter;
yPos = y .* gaborDimPixY + yCenter;

% Count how many Gabors there are
nGabors = numel(xPos);

% Make the destination rectangles for all the Gabors in the array
baseRect = [0 0 gaborDimPixX gaborDimPixY];
allRects = nan(4, nGabors);
for i = 1:nGabors
    allRects(:, i) = CenterRectOnPointd(baseRect, xPos(i), yPos(i));
end

% Drift speed for the 2D global motion
if ~isempty(get(handles.edit6,'string'))
    tFreq = str2double(get(handles.edit6,'string'));
else
    warning('Temporal Frequency automatically set to 2')
    tFreq = 2;
end
degPerSec = 360 * tFreq;
degPerFrame =  degPerSec * ifi;

% Randomise the Gabor orientations and determine the drift speeds of each gabor.
% This is given by multiplying the global motion speed by the cosine
% difference between the global motion direction and the global motion.
% Here the global motion direction is 0. So it is just the cosine of the
% angle we use. We re-orientate the array when drawing
gaborAngles = 0; % rand(1, nGabors) .* 180 - 90;
degPerFrameGabors = cosd(gaborAngles) .* degPerFrame;

% Randomise the phase of the Gabors and make a properties matrix. We could
% if we want have each Gabor with different properties in all dimensions.
% Not just orientation and drift rate as we are doing here.
% This is the power of using procedural textures
phaseLine = 0.5;% rand(1, nGabors) .* 360;
propertiesMat = repmat([NaN, freq, sigma, contrast, aspectRatio, 0, 0, 0],...
    nGabors, 1);
propertiesMat(:, 1) = phaseLine';

waitframes = 1;

angles = 0:10:90;

if ~isempty(get(handles.edit4,'string'))
    tdrift = str2double(get(handles.edit4,'string'));
else
    tdrift = 1;
end

presTimeDrift = repmat(tdrift, 1, numel(angles));
% Animation loop
% while ~KbCheck

sent_data = 'a';
write(arduino,sent_data, 'char');

ServerSend = tcpip('10.93.6.2',50000,'NetworkRole','server', ...
    'OutputBufferSize', 12, 'Terminator', 'CR/LF');
fopen(ServerSend);
fwrite(ServerSend, uint32([(FramesZ*plane_tot) plane_num plane_tot]), 'uint32');
fclose(ServerSend);


% rawData = nan((pixelsX*LinesY),FramesZ);
tcpipServer = tcpip('10.93.6.2',30000,'NetworkRole','client', 'Terminator', 'CR/LF');
tcpipServer.InputBufferSize = (pixelsX*LinesY*200);
fopen(tcpipServer);

Lucky_angle = 1:8;
Lucky_pick = 2;
count_lucks = 0;
n = 0; 
pl = 0;
brk = 0;
while pl < FramesZ*plane_tot
    stm = 0;
    if brk == 1
        break
    end
    if (count_lucks == 0 || count_lucks == 3)
        count_lucks = 0;
        pick_angle = angles(randperm(length(angles),1));
        Lucky_pick  = Lucky_angle(randperm(length(Lucky_angle),1));
        fwd_bkwd = randi([1, 2], 1);
        if pick_angle > 70 && Lucky_pick == 1 && fwd_bkwd == 1
            pick_angle = 50;
        elseif pick_angle < 20 && Lucky_pick == 1 && fwd_bkwd == 2
            pick_angle = 40;
        end
    elseif (count_lucks > 0 && count_lucks < 3)
        if fwd_bkwd == 1
            pick_angle = pick_angle + 20;
        elseif fwd_bkwd == 2
            pick_angle = pick_angle - 20;
        end
    end
    timerVal = tic;
    while toc(timerVal) < tdrift
        pl = pl+1;
        if pl > FramesZ*plane_tot
            break
        end
        rawData = fread(tcpipServer,(pixelsX*LinesY),'uint16');
        try
            rotating_drift.Licks(pl)  = read(arduino, 1, 'uint8');
            flush(arduino, 'input');
        catch
            rotating_drift.Licks(pl)  = rotating_drift.Licks(pl-1) - 1;
            warning ('No Info From Arduino')
        end
        if sum(ismember(pl, frames_sampled)) == 0
            continue
        end
        
        n = n + 1;
        stm = stm + 1;
        if n == 1
            timeStamp = tic;
            rawData_tmp = uint16(reshape(rawData, pixelsX, LinesY));
            rawData_tmp = permute(rawData_tmp, [2 1]);
            rawData_tmp = imcomplement(rawData_tmp);
            % hp = image(im2uint8(rawData_tmp)); %
            hp = imshow(rawData_tmp, [], 'InitialMagnification', 800, 'Parent', hp, 'border', 'tight');
        end
        try
            rawData = reshape(uint16(rawData), pixelsX, LinesY);
        catch
            brk = 1;
            warning('scanbox crashed. Getting out of here to save data')
            break
        end
        rawData = permute(rawData, [2 1]);
        rawData = imcomplement(rawData);
        
        for iroi = 1:length(mask)
            meanRoiOneFrame(iroi,n) = nanmean(rawData(mask{iroi,1}));
        end
        
        set(hp, 'CData',im2uint16(rawData));
        try
            drawnow limitrate nocallbacks
        catch
            warning('Could not plot')
        end
        
        if stm == 1
            Screen('BlendFunction', window, 'GL_ONE', 'GL_ZERO');
            % Draw texture
            Screen('DrawTexture', window, gabortex, [], [], pick_angle,...
                [], [], [], [], kPsychDontDoRotation, propertiesMat');
            Screen('Flip', window, 0, 1);
        end
        %Screen('Flip', window);
        %
        rotating_drift.timeStamp(n) = toc(timeStamp);
        rotating_drift.angle(n) = uint8(pick_angle);
        if Lucky_pick == 1
            rotating_drift.fwd_bkwd(n) = uint8(fwd_bkwd);
        else
            rotating_drift.fwd_bkwd(n) = uint8(0);
        end
    end
    if Lucky_pick == 1 
        count_lucks = count_lucks + 1;
    end
end
%clean up
sca;

fclose(tcpipServer);

delete(tcpipServer);
delete(ServerSend);
ServerSend = [];

% Screen('Flip', window);
% Screen('FillRect', window, [0 0 0]);
% 
% baseline.fullrec = rawData;
rotating_drift.mean = uint16(mean(meanRoiOneFrame,2));
rotating_drift.std  = uint16(std(meanRoiOneFrame,0,2));
rotating_drift.roiData = uint16(meanRoiOneFrame);
rotating_drift.roiMask = mask; 
rotating_drift.nroi = nroi;
rotating_drift.subpop1 = baseline.subpop1;
rotating_drift.subpop2 = baseline.subpop2;
rotating_drift.F0 =F0;

rotating_drift.plane_num = plane_num; 
rotating_drift.plane_tot = plane_tot;

saveTrials = get(handles.checkbox6,'Value');
if saveTrials == 0
    asw = questdlg('You are set not to save this trial. Are you sure this is right?');
    switch asw
        case 'Yes'
            disp ('As you command. I am only here to serve to my true master')
        case 'No'
            return
        case 'cancel'
            return
    end
elseif saveTrials == 1
    if strcmp('D:\Experiments\SessionName',directory)
        answer = questdlg('You are using the default directory to save your data. Are you sure this is right?');
        switch answer
            case 'Yes'
                disp ('As you command. I am only here to serve to my true master')
            case 'No'
                return
            case 'cancel'
                return
        end
    end
    currentCounterValue = str2double(get(handles.edit10, 'String'));
    % Create a new string with the number being 1 more than the current number.
    newString = sprintf('%d', int32(currentCounterValue +1));
    % Send the new string to the text control.
    set(handles.edit10, 'String', newString );
    %     directory = get(handles.edit11, 'String');
    Folder = '\rotating_drift';
    filename1 = ['\rotating_drift' num2str(currentCounterValue)];
    if ~exist([directory Folder], 'dir')
        mkdir([directory Folder])
    end
    save([directory Folder filename1], 'rotating_drift')
end

function edit26_Callback(hObject, eventdata, handles)
% hObject    handle to edit26 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit26 as text
%        str2double(get(hObject,'String')) returns contents of edit26 as a double


% --- Executes during object creation, after setting all properties.
function edit26_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit26 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit27_Callback(hObject, eventdata, handles)
% hObject    handle to edit27 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit27 as text
%        str2double(get(hObject,'String')) returns contents of edit27 as a double


% --- Executes during object creation, after setting all properties.
function edit27_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit27 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in checkbox11.
function checkbox11_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox11 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox11



function edit28_Callback(hObject, eventdata, handles)
% hObject    handle to edit28 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit28 as text
%        str2double(get(hObject,'String')) returns contents of edit28 as a double


% --- Executes during object creation, after setting all properties.
function edit28_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit28 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in checkbox12.
function checkbox12_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox12 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox12



function edit29_Callback(hObject, eventdata, handles)
% hObject    handle to edit29 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit29 as text
%        str2double(get(hObject,'String')) returns contents of edit29 as a double


% --- Executes during object creation, after setting all properties.
function edit29_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit29 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on button press in pushbutton19.
function pushbutton19_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton19 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
clear arduino
arduino = serialport('COM3', 9600);%, 'ErrorOccurredFcn', mycallbackFuck);
pause(2)
% flush(arduino);
sent_data = 'b';
write(arduino,sent_data, 'char');

disp('Reward Delivered');


% --- Executes on button press in checkbox13.
function checkbox13_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox13 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox13


function edit30_Callback(hObject, eventdata, handles)
% hObject    handle to edit30 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit30 as text
%        str2double(get(hObject,'String')) returns contents of edit30 as a double


% --- Executes during object creation, after setting all properties.
function edit30_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit30 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit31_Callback(hObject, eventdata, handles)
% hObject    handle to edit31 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit31 as text
%        str2double(get(hObject,'String')) returns contents of edit31 as a double


% --- Executes during object creation, after setting all properties.
function edit31_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit31 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit32_Callback(hObject, eventdata, handles)
% hObject    handle to edit32 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit32 as text
%        str2double(get(hObject,'String')) returns contents of edit32 as a double


% --- Executes during object creation, after setting all properties.
function edit32_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit32 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function edit33_Callback(hObject, eventdata, handles)
% hObject    handle to edit33 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of edit33 as text
%        str2double(get(hObject,'String')) returns contents of edit33 as a double


% --- Executes during object creation, after setting all properties.
function edit33_CreateFcn(hObject, eventdata, handles)
% hObject    handle to edit33 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
